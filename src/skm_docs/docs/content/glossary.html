<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>认识POM对象 | SKSimulator键鼠模拟器 </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="认识POM对象 | SKSimulator键鼠模拟器 ">
      
      
      <link rel="icon" href="../favicon.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../logo.svg" alt="SKSimulator键鼠模拟器">
            SKSimulator键鼠模拟器
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="认识pom对象">认识POM对象</h1>

<hr>
<p>WeChatAuto.SDK 采用页面对象模型（POM）设计理念，将微信的各类操作场景进行了模块化、清晰的组件封装。你只需要理解这些 POM 对象及其所对应的微信界面组件，就能便捷地调用其公开方法和属性，大幅简化功能开发和后期维护。如果你熟悉 WeChatAuto.SDK 的 POM 组件体系，基本上已经掌握了 60% 的核心用法😊。</p>
<h2 id="-wechatautosdk-pom-组件结构图">🚀 WeChatAuto.SDK POM 组件结构图</h2>
<p><img src="https://raw.githubusercontent.com/scottfly189/WeChatAuto.SDK/master/Images/class.png" alt="WeChatAuto.SDK 主要类关系示意"></p>
<blockquote>
<p>基本上每个POM组件抽象并封装了微信的某个部位</p>
</blockquote>
<h2 id="-wechatautosdk的页面组件介绍">🎁 WeChatAuto.SDK的页面组件介绍</h2>
<p><strong>🎈🎈 基础术语</strong></p>
<ul>
<li><p>主窗口： 微信聊天的主窗口</p>
</li>
<li><p>子窗口： 双击会话打开的弹出窗口</p>
</li>
</ul>
<h3 id="1-wechatclientfactory组件">1. WeChatClientFactory组件</h3>
<p><span style="color: #999;">本组件无UI</span></p>
<p>WeChatClientFactory组件是非常重要的核心组件，负责多微信客户端的统一管理。SDK初始化后，可以通过依赖注入获取该组件。随后，可以通过WeChatClientFactory组件获取具体的微信客户端（<a href="../api/WeChatAuto.Components.WeChatClient.html">WeChatClient</a>）实例，实现对不同微信账号的操作和管理。</p>
<pre><code class="lang-csharp">// 初始化WeAutomation服务
var serviceProvider = WeAutomation.Initialize(options =&gt;
{
    options.DebugMode = true;   //开启调试模式，调试模式会在获得焦点时边框高亮，生产环境建议关闭
    //options.EnableRecordVideo = true;  //开启录制视频功能，录制的视频会保存在项目的运行目录下的Videos文件夹中
});
//获取到WeChatClientFactory
using var clientFactory = serviceProvider.GetRequiredService&lt;WeChatClientFactory&gt;();
</code></pre>
<blockquote>
<p>由于WeChatClientFactory是以<code>Singletion</code>的方式加入依赖注入容器中，所以我们可以很方便的通过构造器注入等方式获取到它,具体请参考<a href="../api/WeChatAuto.Components.WeChatClientFactory.html">WeChatClientFactory</a></p>
</blockquote>
<ul>
<li>WeChatClientFactory组件的Initialize()方法的参数WeChatConfig配置对象说明：</li>
</ul>
<table>
<thead>
<tr>
<th>属性名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>CaptureUIPath</td>
<td>进行截图操作时，捕获UI界面保存的路径 默认保存到当前目录下的Capture文件夹,可以修改为其他路径</td>
</tr>
<tr>
<td>ListenInterval</td>
<td>群或者好友消息监听的时间间隔,单位：秒，默认5秒监听一次</td>
</tr>
<tr>
<td>MomentsListenInterval</td>
<td>朋友圈监听的时间间隔,单位：秒，默认10秒监听一次</td>
</tr>
<tr>
<td>NewUserListenerInterval</td>
<td>监听新用户的时间间隔，单位：秒，默认5秒监听一次</td>
</tr>
<tr>
<td>MonitorSubWinInterval</td>
<td>监听子窗口时间间隔，单位秒,默认5秒监听一次</td>
</tr>
<tr>
<td>DebugMode</td>
<td>是否启用调试模式，启用了调试模式可以在运行时看到按钮高亮，默认false</td>
</tr>
<tr>
<td>EnableRecordVideo</td>
<td>是否启用视频录制，如果启用，可以录制整个自动化运行过程，默认false</td>
</tr>
<tr>
<td>TargetVideoPath</td>
<td>自定义视频录制文件保存位置，默认保存到当前目录下的Video文件夹,可以修改为其他路径</td>
</tr>
<tr>
<td>EnableMouseKeyboardSimulator</td>
<td>是否启用鼠标键盘模拟器,启用后，键盘鼠标操作会通过模拟器进行操作，而不是通过windows automation进行操作,注意：需要购买键鼠模拟器，并在此处启用</td>
</tr>
<tr>
<td>KMDeiviceVID</td>
<td>配置键鼠模拟器设备VID</td>
</tr>
<tr>
<td>KMDeivicePID</td>
<td>配置键鼠模拟器设备PID</td>
</tr>
<tr>
<td>KMVerifyUserData</td>
<td>配置键鼠模拟器用户校验数据</td>
</tr>
<tr>
<td>KMOutputStringType</td>
<td>配置键鼠模拟器输出字符串编码类型,默认使用剪贴板粘贴输出字符串。优点是输出字符多时速度更快且不受输入法影响</td>
</tr>
<tr>
<td>KMMouseMoveMode</td>
<td>配置键鼠模拟器鼠标移动模式</td>
</tr>
<tr>
<td>KMOffsetOfClick</td>
<td>点击偏移量,单位像素,为了避免每次点击都点击到同一个位置，可以设置一个偏移量，实际点击位置为点击位置减去偏移量的一个随机值</td>
</tr>
<tr>
<td>ProcessDpiAwareness</td>
<td>进程DPI感知值,如果使用库的应用已经设置DPI感知，此参数无效，可设置参数为:0: 不设置,进程对DPI完全不知晓，按逻辑像素绘制，可能会出现点击不准确的情况。1: PROCESS_SYSTEM_DPI_AWARE 默认值,进程只根据主显示器DPI绘制，DPI感知生效。 2: PROCESS_PER_MONITOR_DPI_AWARE，进程根据每个显示器DPI绘制,DPI感知生效。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>更具体的了解WeChatConfig配置对象，请参考: <a href="../api/WeAutoCommon.Configs.WeChatConfig.html">WeChatConfig配置对象</a></p>
</blockquote>
<h3 id="2-wechatclient组件">2. WeChatClient组件</h3>
<p><strong>WeChatClient</strong>组件代表一个微信客户端对象，这是整个POM组件体系的<strong>入口</strong>，只有<strong>先</strong>获取<code>WebChatClient</code>,再通过<code>WebChatClient</code>获取POM的其他组件</p>
<p><span style="color: #999;">本组件无UI</span></p>
<ul>
<li>通过<code>WeChatClientFactory</code>获取到<code>WeChatClient</code>对象</li>
<li><code>WeChatClient</code>对象使用委托模式转发调用其他各个组件的方法：如：消息管理，监听等，让客户端只需与 WeChatClient 交互，而不需要了解底层组件,当然更详细的API调用，还得了解<code>WeChatClient</code>包装的其他组件</li>
<li>具体请参见<a href="../api/WeChatAuto.Components.WeChatClient.html">WeChatClient</a>类</li>
</ul>
<h3 id="3-wechatnotifyicon组件">3. WeChatNotifyIcon组件</h3>
<p>本组件封装并抽象了微信在任务栏中的托盘图标（NotifyIcon），如下图所示：</p>
<img src="../Images/notifyicon.png" alt="WeChatNotifyIcon" width="500">
<blockquote>
<p>可以通过WeChatClient.WxNotifyIcon属性获取到WeChatNotifyIcon对象，并执行方法;</p>
</blockquote>
<p>更详细请参考<a href="../api/WeChatAuto.Components.WeChatNotifyIcon.html">WeChatNotifyIcon组件</a></p>
<h3 id="4-wechatmainwindow组件">4. WeChatMainWindow组件</h3>
<p>本组件封装并抽象了微信窗口，封装的微信窗口，包含工具栏、导航栏、搜索、会话列表、通讯录、聊天窗口等</p>
<ul>
<li>可以通过<code>WeChatClient</code>组件的WxMainWindow属性获取到微信客户端所属的WeChatMainWindow组件对象</li>
<li><code>WeChatMainWindow组件</code>可以调用丰富的属性与方法,<code>WeChatMainWindow组件</code>也是各个其他组件的入口</li>
</ul>
<p>对应微信部位如下图所示:</p>
<img src="../Images/wechatwindow.png" alt="WeChatMainWindow" width="500">
<br>
<blockquote>
<p>具体请参考<a href="../api/WeChatAuto.Components.WeChatMainWindow.html">WeChatMainWindow组件</a></p>
</blockquote>
<h3 id="5-toolbar组件">5. Toolbar组件</h3>
<p>本组件封装并抽象了微信右上角的工具栏，可以通过Toolbar组件设置置顶/取消置顶、最小化、最大化、关闭等操作,对应微信的位置如下:</p>
<img src="../Images/toolbar.png" alt="Toolbar" width="500">
<blockquote>
<p>具体请参考<a href="../api/WeChatAuto.Components.ToolBar.html">Toolbar组件</a></p>
</blockquote>
<h3 id="6-navigation组件">6. Navigation组件</h3>
<p>本组件封装并抽象了微信左侧的菜单，可以通过Navigation组件点击左侧的聊天、通讯录、收藏等按钮,对应微信位置如下:</p>
<img src="../Images/Navigation.png" alt="Navigation" width="500">
<blockquote>
<p>具体请参考<a href="../api/WeChatAuto.Components.Navigation.html">Navigation组件</a></p>
</blockquote>
<h3 id="7-moments组件">7. Moments组件</h3>
<p>本组件封装并抽象了微信朋友圈，可以提供打开朋友圈、获取朋友圈内容列表、刷新朋友圈等操作，对应微信的位置如下：</p>
<img src="../Images/monents.png" alt="Moments" width="700">
<blockquote>
<p>具体请参考<a href="../api/WeChatAuto.Components.Moments.html">Moments组件</a></p>
</blockquote>
<h3 id="8-chatcontent组件">8. ChatContent组件</h3>
<p>ChatContent组件是很重要的一个组件，最主要通过它得到<code>ChatHeader</code>、<code>ChatBody</code>等组件，对应微信的位置如下：</p>
<blockquote>
<p>主窗口与子窗口都有ChatContent组件</p>
</blockquote>
<img src="../Images/chatcontent.png" alt="ChatContent" width="500">
<blockquote>
<p>具体请参考<a href="../api/WeChatAuto.Components.ChatContent.html">ChatContent组件</a></p>
</blockquote>
<h3 id="9-chatheader组件">9. ChatHeader组件</h3>
<p>ChatHeader组件提供了获取主窗口与子窗口的聊天对象的标题，对应微信的位置如下：</p>
<blockquote>
<p>主窗口与子窗口都有ChatHeader组件</p>
</blockquote>
<img src="../Images/chatheader.png" alt="ChatHeader" width="700">
<blockquote>
<p>具体请参考<a href="../api/WeChatAuto.Components.ChatHeader.html">ChatHeader组件</a></p>
</blockquote>
<h3 id="10-chatbody组件">10. ChatBody组件</h3>
<p>ChatBody组件封装了聊天体，可以用它来获取聊天列表<code>MessageBubbleList</code>与<code>Sender</code>组件,对应微信的位置如下所示：</p>
<blockquote>
<p>主窗口与子窗口都有ChatBody组件</p>
</blockquote>
<img src="../Images/chatbody.png" alt="ChatBody" width="700">
<blockquote>
<p>具体请参考<a href="../api/WeChatAuto.Components.ChatBody.html">ChatBody组件</a></p>
</blockquote>
<h3 id="11-messagebubblelist组件与messagebubble组件">11. MessageBubbleList组件与MessageBubble组件</h3>
<p><code>MessageBubbleList</code>组件封装了一个聊天列表，一个<code>MessageBubbleList</code>包含多个<code>MessageBubble</code></p>
<p>一个<code>MessageBubble</code>组件封装了一条消息，包括发送消息人，消息内容,时间等信息</p>
<p>对应的微信的位置如下：</p>
<blockquote>
<p>主窗口与子窗口都有MessageBubbleList组件与MessageBubble组件</p>
</blockquote>
<img src="../Images/MessageBubbleList.png" alt="MessageBubbleList组件与MessageBubble组件" width="500">
<blockquote>
<p>具体请参考<a href="../api/WeChatAuto.Components.MessageBubbleList.html">MessageBubbleList组件与MessageBubble组件</a></p>
</blockquote>
<h3 id="12-sender组件">12. Sender组件</h3>
<p>Sender组件封装了一个发送器，可以用它来发送文本消息、Emoji字符串、文件等，对应的微信内容如下:</p>
<blockquote>
<p>主窗口与子窗口都有Sender组件</p>
</blockquote>
<img src="../Images/Sender.png" alt="Sender组件" width="500">
<blockquote>
<p>具体请参考<a href="../api/WeChatAuto.Components.Sender.html">Sender组件</a></p>
</blockquote>
<h3 id="13-conversationlist会话列表组件与conversation组件">13. ConversationList会话列表组件与Conversation组件</h3>
<p>ConversationList组件封装了一个会话列表，Conversation封装了一个会话，对应微信位置如下：</p>
<blockquote>
<p>只有主窗口才有ConversationList会话列表组件与Conversation组件</p>
</blockquote>
<img src="../Images/Conversion.png" alt="SConversationList会话列表组件与Conversation组件" width="500">
<blockquote>
<p>具体请参考<a href="../api/WeChatAuto.Components.ConversationList.html">ConversationList会话列表组件与Conversation组件</a></p>
</blockquote>
<h3 id="14-search组件">14. Search组件</h3>
<p>Search组件封装了微信搜索框,对应微信位置如下:</p>
<blockquote>
<p>只有主窗口才有Search组件</p>
</blockquote>
<img src="../Images/Search.png" alt="Search组件" width="500">
<blockquote>
<p>具体请参考<a href="../api/WeChatAuto.Components.Search.html">Search组件</a></p>
</blockquote>
<h3 id="15-subwinlist组件">15. SubWinList组件</h3>
<p>SubWinList组件封装了所有的子窗口的操作，如：启动子窗口，关闭子窗口，监听子窗口关闭再打开等，对应位置如下:</p>
<blockquote>
<p>可以通过WeChatMainWindow组件得到SubWinList组件</p>
</blockquote>
<img src="../Images/subwinlist.png" alt="SubWinList组件" width="700">
<blockquote>
<p>具体请参考<a href="../api/WeChatAuto.Components.SubWinList.html">SubWinList组件</a></p>
</blockquote>
<h3 id="16-subwin组件">16. SubWin组件</h3>
<p>SubWinList组件封装了一个子窗口,子窗口为双击会话弹出的窗口，可以通过SubWinList获取ChatContent,通过ChatContent获取到MessageBubbleList与Sender等子组件，对应位置如下:</p>
<img src="../Images/SubWin.png" alt="SubWin组件" width="700">
<blockquote>
<p>具体请参考<a href="../api/WeChatAuto.Components.SubWin.html">SubWin组件</a></p>
</blockquote>

</article>

        <div class="contribution d-print-none">
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://github.com/scottfly189/SKSimulator.git">SKSimulator</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
