{
  "api/SKM.Config.html": {
    "href": "api/SKM.Config.html",
    "title": "Class Config | SKSimulator键鼠模拟器",
    "summary": "Class Config Namespace SKM Assembly SKSimulator.dll 参数配置类 public static class Config Inheritance object Config Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties KMDeivicePID 键鼠模拟器设备PID public static int KMDeivicePID { get; set; } Property Value int KMDeiviceVID 键鼠模拟器设备VID public static int KMDeiviceVID { get; set; } Property Value int KMMouseMoveMode 鼠标移动模式 public static int KMMouseMoveMode { get; set; } Property Value int KMOffsetOfClick 点击偏移量,单位像素 为了避免每次点击都点击到同一个位置，可以设置一个偏移量，实际点击位置为点击位置减去偏移量的一个随机值 public static int KMOffsetOfClick { get; set; } Property Value int KMOutputStringType 输出字符串编码类型,默认使用剪贴板粘贴输出字符串。优点是输出字符多时速度更快且不受输入法影响 public static int KMOutputStringType { get; set; } Property Value int KMVerifyUserData 键鼠模拟器校验数据 public static string KMVerifyUserData { get; set; } Property Value string ProcessDpiAwareness 进程DPI感知值,如果使用库的应用已经设置DPI感知，此参数无效。 0: 不设置,进程对DPI完全不知晓，按逻辑像素绘制，可能会出现点击不准确的情况。 1: PROCESS_SYSTEM_DPI_AWARE 默认值,进程只根据主显示器DPI绘制，DPI感知生效。 2: PROCESS_PER_MONITOR_DPI_AWARE，进程根据每个显示器DPI绘制,DPI感知生效。 public static int ProcessDpiAwareness { get; set; } Property Value int"
  },
  "api/SKM.DpiAwareness.html": {
    "href": "api/SKM.DpiAwareness.html",
    "title": "Class DpiAwareness | SKSimulator键鼠模拟器",
    "summary": "Class DpiAwareness Namespace SKM Assembly SKSimulator.dll public static class DpiAwareness Inheritance object DpiAwareness Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods SetProcessDPIAware() 设置进程DPI感知(旧方法) 注意：此方法必须在任何窗口创建之前调用，如果使用库的应用已经设置DPI感知，调用此方法无效 public static extern bool SetProcessDPIAware() Returns bool 是否成功 SetProcessDpiAwareness(int) 设置进程DPI感知,如果使用库的应用已经设置DPI感知，此方法无效。 此方法必须在任何窗口创建之前调用 public static void SetProcessDpiAwareness(int processDpiAwareness) Parameters processDpiAwareness int Exceptions Exception SetProcessDpiAwarenessContext(int) 设置进程DPI感知(新方法) 注意：此方法必须在任何窗口创建之前调用 public static extern int SetProcessDpiAwarenessContext(int value) Parameters value int DPI感知值 Returns int 是否成功"
  },
  "api/SKM.KMSimulatorService.html": {
    "href": "api/SKM.KMSimulatorService.html",
    "title": "Class KMSimulatorService | SKSimulator键鼠模拟器",
    "summary": "Class KMSimulatorService Namespace SKM Assembly SKSimulator.dll 键鼠模拟器服务 封装skm.dll的函数，提供键鼠模拟器服务 x64环境需要复制x64\\skm.dll，x86环境需要复制x86\\skm.dll到当前目录，意思是：x64环境需要使用x64\\skm.dll，x86环境需要使用x86\\skm.dll 本服务类会自动根据当前环境复制DLL到当前目录，可以无感知使用 public static class KMSimulatorService Inheritance object KMSimulatorService Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties DeviceData public static nint DeviceData { get; } Property Value nint Methods CloseDevice() 关闭设备 public static void CloseDevice() Init(int, int, string) public static void Init(int deviceVID, int devicePID, string verifyUserData) Parameters deviceVID int devicePID int verifyUserData string IsDeviceOpen() 判断设备是否打开 public static bool IsDeviceOpen() Returns bool 是否打开 OpenDevice(uint) 打开设备 public static void OpenDevice(uint deviceID) Parameters deviceID uint 设备ID SearchDevice(int, int) 搜索设备 public static uint SearchDevice(int deviceVID, int devicePID) Parameters deviceVID int 设备VID devicePID int 设备PID Returns uint 设备ID"
  },
  "api/SKM.SkmCore.html": {
    "href": "api/SKM.SkmCore.html",
    "title": "Class SkmCore | SKSimulator键鼠模拟器",
    "summary": "Class SkmCore Namespace SKM Assembly SKSimulator.dll 注意: x86 和 x64 的 dll 是不同的，需要根据实际情况选择 x86 的 dll 是 x86\\skm.dll，x64 的 dll 是 x64\\skm.dll 使用 KMSimulatorService 服务类可以无感知使用，会自动根据当前环境复制 DLL 到当前目录 具体 KMSimulatorService 类使用请参考 KMSimulatorService public class SkmCore Inheritance object SkmCore Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods HKMCheckPressedKeysCS(uint) public static string HKMCheckPressedKeysCS(uint Flags) Parameters Flags uint Returns string HKMClose(nint) public static extern bool HKMClose(nint HKMData) Parameters HKMData nint Returns bool HKMDelayRnd(nint, uint, uint) public static extern bool HKMDelayRnd(nint HKMData, uint MinTime, uint MaxTime) Parameters HKMData nint MinTime uint MaxTime uint Returns bool HKMEnableOSMouseAccelerate(bool, bool) public static extern bool HKMEnableOSMouseAccelerate(bool Enable, bool Save) Parameters Enable bool Save bool Returns bool HKMGetCursorPos(nint, ref int, ref int) public static extern bool HKMGetCursorPos(nint HKMData, ref int X, ref int Y) Parameters HKMData nint X int Y int Returns bool HKMGetCursorPos2(nint) public static extern uint HKMGetCursorPos2(nint HKMData) Parameters HKMData nint Returns uint HKMGetDevInfo(nint, uint, bool) public static extern uint HKMGetDevInfo(nint HKMData, uint Index, bool Mouse) Parameters HKMData nint Index uint Mouse bool Returns uint HKMGetDevString(nint, uint, bool, ref uint) public static extern nint HKMGetDevString(nint HKMData, uint Index, bool Mouse, ref uint Length) Parameters HKMData nint Index uint Mouse bool Length uint Returns nint HKMGetDevStringCS(nint, uint, bool) public static string HKMGetDevStringCS(nint HKMData, uint Index, bool Mouse) Parameters HKMData nint Index uint Mouse bool Returns string HKMGetKeyboardLEDState(nint, uint) public static extern bool HKMGetKeyboardLEDState(nint HKMData, uint Index) Parameters HKMData nint Index uint Returns bool HKMGetKeyboardMode(nint) public static extern uint HKMGetKeyboardMode(nint HKMData) Parameters HKMData nint Returns uint HKMGetMouseMode(nint) public static extern uint HKMGetMouseMode(nint HKMData) Parameters HKMData nint Returns uint HKMGetOSMouseSpeed() public static extern int HKMGetOSMouseSpeed() Returns int HKMGetSerialNumber(nint, bool) public static extern uint HKMGetSerialNumber(nint HKMData, bool Mouse) Parameters HKMData nint Mouse bool Returns uint HKMIsKeyBusy(nint) public static extern bool HKMIsKeyBusy(nint HKMData) Parameters HKMData nint Returns bool HKMIsKeyDown(nint, string) public static extern bool HKMIsKeyDown(nint HKMData, string KeyName) Parameters HKMData nint KeyName string Returns bool HKMIsMouseBusy(nint) public static extern bool HKMIsMouseBusy(nint HKMData) Parameters HKMData nint Returns bool HKMIsMouseButtonDown(nint, uint) public static extern bool HKMIsMouseButtonDown(nint HKMData, uint Index) Parameters HKMData nint Index uint Returns bool HKMIsOSMouseAccelerateEnabled() public static extern bool HKMIsOSMouseAccelerateEnabled() Returns bool HKMIsOpen(nint, uint) public static extern bool HKMIsOpen(nint HKMData, uint Flags) Parameters HKMData nint Flags uint Returns bool HKMKeyDown(nint, string) public static extern bool HKMKeyDown(nint HKMData, string KeyName) Parameters HKMData nint KeyName string Returns bool HKMKeyPress(nint, string) public static extern bool HKMKeyPress(nint HKMData, string KeyName) Parameters HKMData nint KeyName string Returns bool HKMKeyUp(nint, string) public static extern bool HKMKeyUp(nint HKMData, string KeyName) Parameters HKMData nint KeyName string Returns bool HKMLeftClick(nint) public static extern bool HKMLeftClick(nint HKMData) Parameters HKMData nint Returns bool HKMLeftDoubleClick(nint) public static extern bool HKMLeftDoubleClick(nint HKMData) Parameters HKMData nint Returns bool HKMLeftDown(nint) public static extern bool HKMLeftDown(nint HKMData) Parameters HKMData nint Returns bool HKMLeftUp(nint) public static extern bool HKMLeftUp(nint HKMData) Parameters HKMData nint Returns bool HKMMiddleClick(nint) public static extern bool HKMMiddleClick(nint HKMData) Parameters HKMData nint Returns bool HKMMiddleDoubleClick(nint) public static extern bool HKMMiddleDoubleClick(nint HKMData) Parameters HKMData nint Returns bool HKMMiddleDown(nint) public static extern bool HKMMiddleDown(nint HKMData) Parameters HKMData nint Returns bool HKMMiddleUp(nint) public static extern bool HKMMiddleUp(nint HKMData) Parameters HKMData nint Returns bool HKMMouseWheel(nint, int) public static extern bool HKMMouseWheel(nint HKMData, int Count) Parameters HKMData nint Count int Returns bool HKMMouseWheelP(nint, int) public static extern bool HKMMouseWheelP(nint HKMData, int Count) Parameters HKMData nint Count int Returns bool HKMMoveR(nint, int, int) public static extern bool HKMMoveR(nint HKMData, int X, int Y) Parameters HKMData nint X int Y int Returns bool HKMMoveR2(nint, int, int) public static extern bool HKMMoveR2(nint HKMData, int X, int Y) Parameters HKMData nint X int Y int Returns bool HKMMoveRP(nint, int, int) public static extern bool HKMMoveRP(nint HKMData, int X, int Y) Parameters HKMData nint X int Y int Returns bool HKMMoveTo(nint, int, int) public static extern bool HKMMoveTo(nint HKMData, int X, int Y) Parameters HKMData nint X int Y int Returns bool HKMOpen(uint, uint) public static extern nint HKMOpen(uint DeviceId, uint DpiMode) Parameters DeviceId uint DpiMode uint Returns nint HKMOpen2(uint, uint, uint) public static extern nint HKMOpen2(uint DeviceId1, uint DeviceId2, uint DpiMode) Parameters DeviceId1 uint DeviceId2 uint DpiMode uint Returns nint HKMOutputString(nint, string) public static extern bool HKMOutputString(nint HKMData, string Str) Parameters HKMData nint Str string Returns bool HKMReleaseKeyboard(nint) public static extern bool HKMReleaseKeyboard(nint HKMData) Parameters HKMData nint Returns bool HKMReleaseMouse(nint) public static extern bool HKMReleaseMouse(nint HKMData) Parameters HKMData nint Returns bool HKMRightClick(nint) public static extern bool HKMRightClick(nint HKMData) Parameters HKMData nint Returns bool HKMRightDoubleClick(nint) public static extern bool HKMRightDoubleClick(nint HKMData) Parameters HKMData nint Returns bool HKMRightDown(nint) public static extern bool HKMRightDown(nint HKMData) Parameters HKMData nint Returns bool HKMRightUp(nint) public static extern bool HKMRightUp(nint HKMData) Parameters HKMData nint Returns bool HKMSearchDevice(uint, uint, uint) public static extern uint HKMSearchDevice(uint Vid, uint Pid, uint DeviceType) Parameters Vid uint Pid uint DeviceType uint Returns uint HKMSearchDevice2(uint, uint, uint, uint) public static extern uint HKMSearchDevice2(uint Vid, uint Pid, uint SN, uint DeviceType) Parameters Vid uint Pid uint SN uint DeviceType uint Returns uint HKMSearchDeviceAll(uint, uint, uint) public static extern nint HKMSearchDeviceAll(uint Vid, uint Pid, uint DeviceType) Parameters Vid uint Pid uint DeviceType uint Returns nint HKMSetAbsMouseScrnRes(nint, int, int) public static extern bool HKMSetAbsMouseScrnRes(nint HKMData, int Width, int Height) Parameters HKMData nint Width int Height int Returns bool HKMSetKeyInterval(nint, uint, uint) public static extern bool HKMSetKeyInterval(nint HKMData, uint MinTime, uint MaxTime) Parameters HKMData nint MinTime uint MaxTime uint Returns bool HKMSetLightMode(nint, uint, bool) public static extern bool HKMSetLightMode(nint HKMData, uint Mode, bool Mouse) Parameters HKMData nint Mode uint Mouse bool Returns bool HKMSetMode(nint, uint, uint) public static extern bool HKMSetMode(nint HKMData, uint Index, uint Mode) Parameters HKMData nint Index uint Mode uint Returns bool HKMSetMouseInterval(nint, uint, uint) public static extern bool HKMSetMouseInterval(nint HKMData, uint MinTime, uint MaxTime) Parameters HKMData nint MinTime uint MaxTime uint Returns bool HKMSetMouseMoveTimeout(nint, uint) public static extern bool HKMSetMouseMoveTimeout(nint HKMData, uint Timeout) Parameters HKMData nint Timeout uint Returns bool HKMSetMousePosMaxOffset(nint, uint) public static extern bool HKMSetMousePosMaxOffset(nint HKMData, uint dwOffset) Parameters HKMData nint dwOffset uint Returns bool HKMSetMousePosPrecision(nint, uint) public static extern bool HKMSetMousePosPrecision(nint HKMData, uint Precision) Parameters HKMData nint Precision uint Returns bool HKMSetMouseSpeed(nint, uint) public static extern bool HKMSetMouseSpeed(nint HKMData, uint MouseSpeed) Parameters HKMData nint MouseSpeed uint Returns bool HKMSetOSMouseSpeed(int, bool) public static extern bool HKMSetOSMouseSpeed(int Speed, bool Save) Parameters Speed int Save bool Returns bool HKMSetResetMode(nint, uint, bool) public static extern bool HKMSetResetMode(nint HKMData, uint Mode, bool Mouse) Parameters HKMData nint Mode uint Mouse bool Returns bool HKMSetResetTime(nint, uint, bool) public static extern bool HKMSetResetTime(nint HKMData, uint Time, bool Mouse) Parameters HKMData nint Time uint Mouse bool Returns bool HKMVerifyUserData(nint, string, bool) public static extern bool HKMVerifyUserData(nint HKMData, string Str, bool Mouse) Parameters HKMData nint Str string Mouse bool Returns bool HKMVerifyUserData2(nint, string, bool) public static extern uint HKMVerifyUserData2(nint HKMData, string Str, bool Mouse) Parameters HKMData nint Str string Mouse bool Returns uint HKMXBtn1Click(nint) public static extern bool HKMXBtn1Click(nint HKMData) Parameters HKMData nint Returns bool HKMXBtn1DoubleClick(nint) public static extern bool HKMXBtn1DoubleClick(nint HKMData) Parameters HKMData nint Returns bool HKMXBtn1Down(nint) public static extern bool HKMXBtn1Down(nint HKMData) Parameters HKMData nint Returns bool HKMXBtn1Up(nint) public static extern bool HKMXBtn1Up(nint HKMData) Parameters HKMData nint Returns bool HKMXBtn2Click(nint) public static extern bool HKMXBtn2Click(nint HKMData) Parameters HKMData nint Returns bool HKMXBtn2DoubleClick(nint) public static extern bool HKMXBtn2DoubleClick(nint HKMData) Parameters HKMData nint Returns bool HKMXBtn2Down(nint) public static extern bool HKMXBtn2Down(nint HKMData) Parameters HKMData nint Returns bool HKMXBtn2Up(nint) public static extern bool HKMXBtn2Up(nint HKMData) Parameters HKMData nint Returns bool"
  },
  "api/SKM.html": {
    "href": "api/SKM.html",
    "title": "Namespace SKM | SKSimulator键鼠模拟器",
    "summary": "Namespace SKM Classes Config 参数配置类 DpiAwareness KMSimulatorService 键鼠模拟器服务 封装skm.dll的函数，提供键鼠模拟器服务 x64环境需要复制x64\\skm.dll，x86环境需要复制x86\\skm.dll到当前目录，意思是：x64环境需要使用x64\\skm.dll，x86环境需要使用x86\\skm.dll 本服务类会自动根据当前环境复制DLL到当前目录，可以无感知使用 SkmCore 注意: x86 和 x64 的 dll 是不同的，需要根据实际情况选择 x86 的 dll 是 x86\\skm.dll，x64 的 dll 是 x64\\skm.dll 使用 KMSimulatorService 服务类可以无感知使用，会自动根据当前环境复制 DLL 到当前目录 具体 KMSimulatorService 类使用请参考 KMSimulatorService"
  },
  "content/faq.html": {
    "href": "content/faq.html",
    "title": "FAQ | SKSimulator键鼠模拟器",
    "summary": "FAQ 你提，我来回答\uD83D\uDE0A"
  },
  "content/quick-start.html": {
    "href": "content/quick-start.html",
    "title": "\uD83D\uDC49 快速开始 | SKSimulator键鼠模拟器",
    "summary": "\uD83D\uDC49 快速开始 \uD83C\uDF88 前置条件 本SDK基于Windows的UI Automation开发，所以仅支持Windows 操作系统，并且需要将项目的TargetFramework修改成:目标框架-windows,如你在.net8下使用，请将TargetFramework修改成net8.0-windows; .NET Framework 4.8+ 或 .NET 6.0+ (Windows)，支持.NET的框架有:net48;net481;net6.0-windows; net7.0-windows;net8.0-windows;net9.0-windows;net10.0-windows; 微信 PC 客户端已安装并运行,本 SDK 基于微信 PC 客户端(版本号:3.9.12.55)的 UI 结构开发，不同版本可能存在兼容性问题。 \uD83C\uDF89 安装 通过 NuGet 安装： dotnet add package WeChatAuto.SDK \uD83C\uDF89 WeChatAuto.SDK的初始化 WeChatAuto.SDK的初始化的通用格式为: WeAutomation.Initialize(...,Action<WeChatConfig> options) 但根据应用依赖注入引入的情况分两种情况： 应用没有启用依赖注入 此种情况需要自行引入dotnet add package Microsoft.Extensions.DependencyInjection包,这样应用也有了依赖注入容器,并且根据情况初始化WeChatConfig配置对象，如下所示: // 初始化WeAutomation服务 var serviceProvider = WeAutomation.Initialize(options => { options.DebugMode = true; //开启调试模式，调试模式会在获得焦点时边框高亮，生产环境建议关闭 //options.EnableRecordVideo = true; //开启录制视频功能，录制的视频会保存在项目的运行目录下的Videos文件夹中 }); using var clientFactory = serviceProvider.GetRequiredService<WeChatClientFactory>(); ...下面是更多代码 注意：如果应用没有启用依赖注入，clientFactory的生命周期需要自行负责，或者应用退出的时候显式clientFactory.Dispose(),或者将clientFactory放入using {}代码块中自动释放 应用启用了依赖注入框架 此种情况，需要在应用Services.BuildServiceProvider()前进行初始化,并将应用的Services做为初始化的第一个参数，这样本SDK就集成在应用的依赖注入框架中，如下所示: using Microsoft.Extensions.Hosting; using WeChatAuto.Services; using WeChatAuto.Components; using Microsoft.Extensions.DependencyInjection; using Microsoft.Extensions.Logging; var builder = Host.CreateApplicationBuilder(args); WeAutomation.Initialize(builder.Services, options => { //开启调试模式，调试模式会在获得焦点时边框高亮，生产环境建议关闭 options.DebugMode = true; //开启录制视频功能，录制的视频会保存在项目的运行目录下的Videos文件夹中 //options.EnableRecordVideo = true; }); //这里注入自已的服务（或者对象），如LLM服务等 builder.Services.AddSingleton<LLMService>(); var serviceProvider = builder.Services.BuildServiceProvider(); var clientFactory = serviceProvider.GetRequiredService<WeChatClientFactory>(); ...更多代码 await builder.Build().RunAsync(); ... 此种方式的初始化无须管理clientFactory的生命周期 \uD83D\uDE0A 基本使用 示例一: 给好友（或群聊昵称）发送消息： 源码请参见: 项目根目录\\Examples\\demo01 步骤一：新建项目，如下所示: dotnet new console -n demo01 步骤二：将demo01.csproj项目文件的net10.0修改成net10.0-windows,如下所示: <PropertyGroup> <OutputType>Exe</OutputType> <TargetFramework>net10.0-windows</TargetFramework> <ImplicitUsings>enable</ImplicitUsings> <Nullable>enable</Nullable> </PropertyGroup> 步骤三：安装依赖 dotnet add package WeChatAuto.SDK dotnet add package Microsoft.Extensions.DependencyInjection 步骤四：项目demo01的Program.cs修改成如下： using Microsoft.Extensions.DependencyInjection; using WeChatAuto.Components; using WeChatAuto.Services; // 初始化WeAutomation服务 var serviceProvider = WeAutomation.Initialize(options => { options.DebugMode = true; //开启调试模式，调试模式会在获得焦点时边框高亮，生产环境建议关闭 //options.EnableRecordVideo = true; //开启录制视频功能，录制的视频会保存在项目的运行目录下的Videos文件夹中 }); using var clientFactory = serviceProvider.GetRequiredService<WeChatClientFactory>(); Console.WriteLine($\"当前客户端打开的微信客户端为：{string.Join(\",\", clientFactory.GetWeChatClientNames())}，共计{clientFactory.GetWeChatClientNames().Count}个微信客户端。\"); //获取当前打开的微信客户端名称列表 var clientNames = clientFactory.GetWeChatClientNames(); //获取第一个微信客户端 var wxClient = clientFactory.GetWeChatClient(clientNames.First()); //通过微信客户端发送消息给好友昵称AI.Net，测试时请把AI.Net修改成自己的好友昵称 wxClient?.SendWho(\"AI.Net\",\"你好，欢迎使用AI.Net微信自动化框架！\"); 注意： 本项目仅支持 Windows 系统，请务必将项目文件的 TargetFramework 设置为 netxx.0-windows（如 net10.0-windows），否则编译时会出现警告。后续不再赘述。 如果是手动管理WeChatClientFactory,请在应用结束时运行clientFactory.Dispose(),或者像示例代码一样将代码放入using块自动释放,如果把WeChatAuto.SDK加入您的依赖注入容器，则不存在此问题。 WeAutomation.Initialize()方法有两个重载，分别适用于：加入外部依赖注入与使用内部依赖注入。 示例二 - 演示监听好友（或者群聊昵称）的消息,使用消息上下文获取消息并回复,并且还演示了如何通过依赖注入获取消息上下文的注入对象,执行自己的业务逻辑： 源码请参见: 项目根目录\\Examples\\demo02 前置步骤：安装依赖 dotnet add package WeChatAuto.SDK dotnet add package Microsoft.Extensions.Hosting 将项目demo02的Program.cs修改成如下 using Microsoft.Extensions.Hosting; using WeChatAuto.Services; using WeChatAuto.Components; using Microsoft.Extensions.DependencyInjection; using Microsoft.Extensions.Logging; var builder = Host.CreateApplicationBuilder(args); WeAutomation.Initialize(builder.Services, options => { //开启调试模式，调试模式会在获得焦点时边框高亮，生产环境建议关闭 options.DebugMode = true; //开启录制视频功能，录制的视频会保存在项目的运行目录下的Videos文件夹中 //options.EnableRecordVideo = true; }); //这里注入自已的服务（或者对象），如LLM服务等 builder.Services.AddSingleton<LLMService>(); var serviceProvider = builder.Services.BuildServiceProvider(); var clientFactory = serviceProvider.GetRequiredService<WeChatClientFactory>(); // 得到名称为\"Alex\"的微信客户端实例，测试时请将AI.net替换为你自己的微信昵称 var client = clientFactory.GetWeChatClient(\"Alex\"); // 监听微信群测试11 await client.AddMessageListener(\"测试11\", (messageContext) => { var index = 0; //打印收到最新消息 foreach (var message in messageContext.NewMessages) { index++; Console.WriteLine($\"收到消息：{index}：{message.ToString()}\"); Console.WriteLine($\"收到消息：{index}：{message.Who}：{message.MessageContent}\"); } //打印收到所有消息的后十条 var allMessages = messageContext.AllMessages.Skip(messageContext.AllMessages.Count - 10).ToList(); index = 0; foreach (var message in allMessages) { index++; Console.WriteLine($\"...收到所有消息的后10条之第{index}条：{message.Who}：{message.MessageContent}\"); Console.WriteLine($\".................详细之第{index}条：{message.ToString()}\"); } //是否有人@我 if (messageContext.IsBeAt()) { var messageBubble = messageContext.MessageBubbleIsBeAt().FirstOrDefault(); if (messageBubble != null) { messageContext.SendMessage(\"我被@了！！！！我马上就回复你！！！！\", new List<string> { messageBubble.Who }); } else { messageContext.SendMessage(\"我被@了！！！！我马上就回复你！！！！\"); } } //是否有人引用了我的消息 if (messageContext.IsBeReferenced()) { messageContext.SendMessage(\"我被引用了！！！！\"); } //是否有人拍了拍我 if (messageContext.IsBeTap()) { messageContext.SendMessage(\"我被拍一拍了[微笑]！！！！\"); } if (!messageContext.IsBeAt() && !messageContext.IsBeReferenced() && !messageContext.IsBeTap()) { //回复消息，这里可以引入大模型自动回复 messageContext.SendMessage($\"我收到了{messageContext.NewMessages.FirstOrDefault()?.Who}的消息：{messageContext.NewMessages.FirstOrDefault()?.MessageContent}\"); } //可以通过注入的服务容器获取你注入的服务实例，然后调用你的业务逻辑,一般都是LLM的自动回复逻辑 var llmService = messageContext.ServiceProvider.GetRequiredService<LLMService>(); llmService.DoSomething(); }); var app = builder.Build(); await app.RunAsync(); /// <summary> /// 一个包含LLM服务的Service类，用于注入到MessageContext中 /// </summary> public class LLMService { private ILogger<LLMService> _logger; public LLMService(ILogger<LLMService> logger) { _logger = logger; } public void DoSomething() { _logger.LogInformation(\"这里是你注入的服务实例，可以在这里编写你的业务逻辑 \"); } } 前置步骤跟Demo01一致,可以通过messageContext对象执行各种操作,也可以通过messageContext对象获得依赖注入容器，获取自己的对象，执行自己的业务逻辑; 示例三 - MCP Server的使用 - 以vscode为例讲解 进入源码的.vscode\\mcp.json,修改配置如下: { \"servers\": { \"wechat_mcp_server\": { \"type\": \"stdio\", \"command\": \"dotnet\", \"args\": [ \"run\", \"--project\", \"改成你的WeChatAuto.MCP.csproj的路径\" ] } } } 在mcp.json页面点击\"Start\"按钮启动mcp server 启动GitHub Copilot Chat,在Chat页提问: 请帮我给微信好友:AI.Net发送消息：Hello world!"
  },
  "content/standard-dll-interface-function.html": {
    "href": "content/standard-dll-interface-function.html",
    "title": "标准DLL接口函数 | SKSimulator键鼠模拟器",
    "summary": "标准DLL接口函数"
  },
  "content/virtual-code-table.html": {
    "href": "content/virtual-code-table.html",
    "title": "虚拟码键表 | SKSimulator键鼠模拟器",
    "summary": "虚拟码键表 键码 键名 描述 键码 键名 描述 8 Backspace 退格键 88 X 9 Tab Tab键 89 Y 13 Enter 回车键 90 Z 16 Shift Shift键 91 Left Win 左Windows键 17 Ctrl Ctrl键 92 Right Win 右Windows键 18 Alt Alt键 93 Apps 菜单键 19 Pause 暂停键 96 Num 0 小键盘0键 20 Caps Lock 大小写切换键 97 Num 1 小键盘1键 27 Esc 退出键 98 Num 2 小键盘2键 32 Space 空格键 99 Num 3 小键盘3键 33 Page Up 向上翻页键 100 Num 4 小键盘4键 34 Page Down 向下翻页键 101 Num 5 小键盘5键 35 End 结尾键 102 Num 6 小键盘6键 36 Home 起始键 103 Num 7 小键盘7键 37 Left 左移键（左箭头） 104 Num 8 小键盘8键 38 Up 上移键（上箭头） 105 Num 9 小键盘9键 39 Right 右移键（右箭头） 106 Num * 小键盘*键 40 Down 下移键（下箭头） 107 Num + 小键盘+键 44 Print Screen 截屏键 108 Num Enter 小键盘回车键 45 Insert 插入键 109 Num - 小键盘-键 46 Delete 删除键 110 Num . 小键盘.键 48 0 111 Num / 小键盘/键 49 1 112 F1 50 2 113 F2 51 3 114 F3 52 4 115 F4 53 5 116 F5 54 6 117 F6 55 7 118 F7 56 8 119 F8 57 9 120 F9 65 A 121 F10 66 B 122 F11 67 C 123 F12 68 D 144 Num Lock 小键盘切换键 69 E 145 Scroll Lock 70 F 160 Left Shift 左Shift键 71 G 161 Right Shift 右Shift键 72 H 162 Left Ctrl 左Ctrl键 73 I 163 Right Ctrl 右Ctrl键 74 J 164 Left Alt 左Alt键 75 K 165 Right Alt 右Alt键 76 L 186 ; ;: 77 M 187 = =+ 78 N 188 , ,< 79 O 189 - -_ 80 P 190 . .> 81 Q 191 / /? 82 R 192 |~ 83 S 219 [ [{ 84 T 220 \\ | 85 U 221 ] ]} 86 V 222 ' '\" 87 W"
  },
  "device.html": {
    "href": "device.html",
    "title": "键鼠模拟器购买 | SKSimulator键鼠模拟器",
    "summary": "键鼠模拟器购买 本 SDK 需要配合专用的键鼠模拟器硬件设备使用。该硬件设备通过 USB HID 接口连接，能够以硬件级别模拟键盘和鼠标输入，具有极高的隐蔽性和安全性。 \uD83D\uDCE6 产品信息 设备类型: USB HID 键鼠模拟器 接口类型: USB 2.0/3.0 支持系统: Windows 操作系统 设备 VID: 0x2612 可定制 设备 PID: 0x1701 可定制 用户加密: 可定制,方便用户分发与授权管理 驱动方式: 免驱动（即插即用） \uD83D\uDCF8 键鼠模拟器实拍照片 \uD83D\uDCB3 购买流程 1. 联系购买 购买价格: 129元/个 如需购买键鼠模拟器硬件设备，请通过以下方式联系： 温馨提示：添加好友时请备注“键鼠”，否则可能无法通过好友申请。 2. 购买时凭证 购买时请提供以下信息，以便我们为您提供准确的产品和售后服务： 购买数量: 需要购买的数量 收货地址: 详细的收货地址和联系方式 用途说明: 简要说明使用场景（用于技术开发、自动化测试等） 发票需求: 暂不支持开具发票。如您有特殊发票需求，请提前沟通，我们将尽力协助，但目前仅支持个人/非企业用户购买。 4. 发货信息 发货时间: 目前每台键鼠模拟器均为定制化小批量生产，确保每台设备质量可靠。一般情况下，订单确认后将在 6 个工作日内安排发货，如果需求数量大，或者遇特殊情况（如材料短缺、生产排单等）会及时与您沟通协商具体发货时间，请您谅解,如无法接受此发货周期，请谨慎下单。 物流方式: 顺丰快递 / 其他快递（根据地区选择） 包装说明: 每个设备独立包装，含防静电袋和保护材料 ✅ 质量保证 质保政策 质保期限: 自收货之日起 3 个月 质保范围: 设备硬件故障（非人为损坏） 无法正常识别或连接 功能异常（按键/鼠标模拟失效） 质保方式: 免费维修或更换 承担往返运费 提供技术支持 技术支持 技术支持内容: SDK 集成指导 设备使用问题解答 代码示例提供 常见问题排查 支持渠道: GitHub Issues 技术文档 在线咨询 ⚠️ 注意事宜 购买前注意事项 兼容性确认 确认您的开发环境为 Windows 系统 确认项目需要硬件级别的键鼠模拟功能 了解 SDK 的使用要求和限制 数量规划 根据实际项目需求确定购买数量 建议先购买少量进行测试验证 批量采购可享受优惠价格（请咨询） 技术支持 购买前可先查看项目文档和示例代码 如有技术问题，建议先查阅文档或提交 Issue 购买后我们将提供更详细的技术支持 使用注意事项 设备连接 首次使用前，请确保设备正确插入 USB 接口 建议使用 USB 2.0 或更高版本接口 避免使用 USB 延长线或集线器（可能影响稳定性） 驱动安装 设备为免驱动设计，Windows 系统会自动识别 如系统无法识别，请检查 USB 接口和线缆 可在设备管理器中查看设备状态 SDK 配置 购买后，您将获得对应的设备 VID/PID 和校验数据 请妥善保管校验数据，用于 SDK 初始化 按照 README.md 中的说明进行配置 合法使用 本设备仅用于合法的自动化测试、开发调试等场景 请勿用于任何违法违规活动 使用本设备产生的任何法律后果由使用者自行承担 设备维护 避免设备受潮、高温或强烈震动 不使用时建议妥善保管 定期检查 USB 接口和线缆的完好性 重要提示: 本设备为专用硬件，需要配合本 SDK 使用 购买前请确认您的使用场景和需求 如有疑问，建议先咨询后再购买"
  },
  "index.html": {
    "href": "index.html",
    "title": "SKSimulator - 键鼠模拟器 SDK | SKSimulator键鼠模拟器",
    "summary": "SKSimulator - 键鼠模拟器 SDK 键鼠模拟器是一类专用硬件设备，能够通过底层信号模拟真实的键盘与鼠标输入操作。相比于传统的 PostMessage、SendInput、SetWindowsHookEx 等 Windows API 注入方式，软件模拟常常会被安全监控系统检测到（如获取窗口焦点、输入来源判别、消息钩子分析等），从而被微信、企业微信等主流应用识别为自动化行为，存在较高的风控和封号风险。而采用硬件级别的信号注入，输入几乎等同于真实用户操作，不会留下易被检测的 API 调用特征，具备极高的隐蔽性和安全性，非常适合需要高安全性的自动化场景。 \uD83D\uDD04 工作原理对比 ┌─────────────────────────────────────────────────────────────────────────┐ │ 传统软件模拟方式 │ └─────────────────────────────────────────────────────────────────────────┘ 应用程序 │ ├─→ PostMessage/SendInput/SetWindowsHookEx │ │ │ ├─→ Windows API 调用 │ │ │ │ │ ├─→ ⚠️ 可被检测特征 │ │ │ ├─ 窗口焦点获取 │ │ │ ├─ 输入来源判别 │ │ │ └─ 消息钩子分析 │ │ │ │ │ └─→ 安全监控系统 │ │ │ │ │ └─→ ❌ 识别为自动化行为 │ │ └─→ 风控/封号风险 │ │ └─────────┴─────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────────────┐ │ 硬件键鼠模拟器方式 │ └─────────────────────────────────────────────────────────────────────────┘ 应用程序 │ ├─→ SKSimulator SDK │ │ │ ├─→ skm.dll (硬件驱动) │ │ │ │ │ └─→ \uD83D\uDD0C 硬件设备 (USB HID) │ │ │ │ │ ├─→ ✅ 底层信号注入 │ │ │ ├─ 硬件级别输入 │ │ │ ├─ 无 API 调用特征 │ │ │ └─ 等同于真实用户操作 │ │ │ │ │ └─→ 操作系统 │ │ │ │ │ └─→ ✅ 识别为真实输入 │ │ └─→ 高隐蔽性/安全性 │ │ └─────────┴─────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────────────┐ │ 对比总结 │ ├─────────────────────────────────────────────────────────────────────────┤ │ │ │ 传统软件模拟 │ 硬件键鼠模拟器 │ │ ───────────── │ ───────────── │ │ ❌ 易被检测 │ ✅ 高隐蔽性 │ │ ❌ API 调用特征 │ ✅ 无 API 特征 │ │ ❌ 风控风险高 │ ✅ 安全性高 │ │ ❌ 可能被封号 │ ✅ 等同于真实操作 │ │ │ └─────────────────────────────────────────────────────────────────────────┘ 本 SDK 采用 C# 实现，完整支持键盘和鼠标的各类操作，同时兼容 x86 与 x64 架构，自动管理 DLL 加载和依赖，无需手动干预。 \uD83D\uDC49 本键鼠模拟器也支持 C++ 集成。 x86 架构：包含并链接 x86/HKM.h 和 x86/hkm.lib x64 架构：包含并链接 x64/HKM.h 和 x64/hkm.lib 只需在对应平台下引入相关头文件和库文件，即可方便调用 DLL 接口。 ✨ 功能特性 \uD83C\uDFAF 完整的键鼠模拟功能 - 支持键盘按键、鼠标移动、点击等所有操作 \uD83D\uDD27 自动 DLL 管理 - 自动根据运行环境（x86/x64）复制对应的 DLL 文件 \uD83D\uDCDD 字符串输出 - 支持 Unicode 和 ANSI 编码，支持中文输入 \uD83D\uDDB1️ DPI 感知 - 支持多显示器 DPI 感知，确保坐标精度 ⚙️ 灵活配置 - 可配置设备参数、输出模式、鼠标移动模式等 \uD83D\uDD12 设备验证 - 内置校验机制，提升安全性，支持硬件分发与授权管理 ⏱️ 随机延时 - 内置随机延时功能，模拟更真实的操作 \uD83D\uDCCB 系统要求 Windows 操作系统 键鼠模拟器硬件设备。本 SDK 需要配合硬件使用，如需硬件设备，请联系我 \uD83D\uDE80 快速开始 1. 克隆项目 git clone https://github.com/scottfly189/SKSimulator.git cd src 2. 配置设备参数 在 Config.cs 中配置您的设备参数： public static int KMDeiviceVID { get; set; } = 0x2612; // 设备 VID public static int KMDeivicePID { get; set; } = 0x1701; // 设备 PID public static string KMVerifyUserData { get; set; } = \"您的校验数据\"; 3. 准备 DLL 文件 确保 x64/skm.dll 和 x86/skm.dll 文件存在于项目中。项目会自动根据运行环境复制对应的 DLL。 如下所示将 DLL 文件包含在项目中： <!-- 复制DLL到输出目录 --> <ItemGroup> <None Include=\"x64\\skm.dll\"> <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory> <TargetPath>x64\\skm.dll</TargetPath> </None> <None Include=\"x86\\skm.dll\"> <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory> <TargetPath>x86\\skm.dll</TargetPath> </None> </ItemGroup> 4. 编译运行 dotnet build dotnet run \uD83D\uDCD6 使用示例 基本使用 using SKM; // 初始化设备 KMSimulatorService.Init(Config.KMDeiviceVID, Config.KMDeivicePID, Config.KMVerifyUserData); IntPtr HKMData = KMSimulatorService.DeviceData; // 设置模式（输出字符串编码、鼠标移动模式） SkmCore.HKMSetMode(HKMData, 4, 4); // 键盘操作示例 SkmCore.HKMKeyPress(HKMData, \"WIN+E\"); // 组合键 SkmCore.HKMKeyDown(HKMData, \"Ctrl\"); SkmCore.HKMKeyPress(HKMData, \"A\"); SkmCore.HKMKeyUp(HKMData, \"Ctrl\"); // 输出字符串（支持中文） SkmCore.HKMOutputString(HKMData, \"ABC中文，可以打成全部是中文吗？\"); SkmCore.HKMOutputString(HKMData, \"\\r\\n换行测试，Hello World!\"); // 鼠标操作示例 SkmCore.HKMMoveR(HKMData, 100, 50); // 相对移动 SkmCore.HKMMoveTo(HKMData, 200, 100); // 绝对移动 SkmCore.HKMLeftClick(HKMData); // 左键单击 SkmCore.HKMRightClick(HKMData); // 右键单击 SkmCore.HKMLeftDoubleClick(HKMData); // 左键双击 // 随机延时 SkmCore.HKMDelayRnd(HKMData, 100, 150); // 关闭设备 KMSimulatorService.CloseDevice(); 完整示例 参考 Program.cs 中的完整示例代码。 \uD83D\uDD27 配置说明 Config 类配置项 配置项 类型 默认值 说明 KMDeiviceVID int 0x2612 键鼠模拟器设备 VID KMDeivicePID int 0x1701 键鼠模拟器设备 PID KMVerifyUserData string - 键鼠模拟器校验数据 KMOffsetOfClick int 5 点击偏移量（像素） KMOutputStringType int 4 输出字符串编码类型 KMMouseMoveMode int 0 鼠标移动模式 ProcessDpiAwareness int 1 进程 DPI 感知值 DPI 感知配置 0: 不设置 DPI 感知 1: PROCESS_SYSTEM_DPI_AWARE - 根据主显示器 DPI（默认） 2: PROCESS_PER_MONITOR_DPI_AWARE - 根据每个显示器 DPI 注意: 键鼠模拟器受 DPI 感知影响，请正确设置 DPI。本 SDK 中也提供了 DpiAwareness 类供设置 DPI。 \uD83D\uDCDA API 文档 KMSimulatorService 类 设备管理服务类，提供设备初始化、搜索、打开、关闭等功能。 主要方法 Init(int deviceVID, int devicePID, string verifyUserData) - 初始化设备 SearchDevice(int deviceVID, int devicePID) - 搜索设备 OpenDevice(UInt32 deviceID) - 打开设备 CloseDevice() - 关闭设备 IsDeviceOpen() - 判断设备是否打开 SkmCore 类 skm.dll 的封装类，提供所有底层 API。 键盘操作 HKMKeyPress(IntPtr HKMData, string KeyName) - 按键 HKMKeyDown(IntPtr HKMData, string KeyName) - 按下 HKMKeyUp(IntPtr HKMData, string KeyName) - 弹起 HKMOutputString(IntPtr HKMData, string Str) - 输出字符串 HKMReleaseKeyboard(IntPtr HKMData) - 释放所有按键 鼠标操作 HKMMoveTo(IntPtr HKMData, int X, int Y) - 绝对移动 HKMMoveR(IntPtr HKMData, int X, int Y) - 相对移动 HKMLeftClick(IntPtr HKMData) - 左键单击 HKMRightClick(IntPtr HKMData) - 右键单击 HKMMiddleClick(IntPtr HKMData) - 中键单击 HKMLeftDoubleClick(IntPtr HKMData) - 左键双击 HKMMouseWheel(IntPtr HKMData, int Count) - 滚轮滚动 设备管理 HKMSearchDevice(UInt32 Vid, UInt32 Pid, UInt32 DeviceType) - 搜索设备 HKMOpen(UInt32 DeviceId, UInt32 DpiMode) - 打开设备 HKMClose(IntPtr HKMData) - 关闭设备 HKMSetMode(IntPtr HKMData, UInt32 Index, UInt32 Mode) - 设置模式 工具方法 HKMDelayRnd(IntPtr HKMData, UInt32 MinTime, UInt32 MaxTime) - 随机延时 HKMGetCursorPos(IntPtr HKMData, ref int X, ref int Y) - 获取鼠标坐标 更多 API 请参考 SKMCore.cs 文件。 更多的使用注意事宜与全部的标准API接口 请阅读 SKSimulator 官方文档 ⚠️ 注意事项 DLL 文件: x64 环境需要使用 x64/skm.dll x86 环境需要使用 x86/skm.dll KMSimulatorService 会自动根据当前环境复制 DLL，无需手动处理 DPI 感知: DPI 感知设置必须在任何窗口创建之前调用 如果应用程序已经设置了 DPI 感知，库的设置将无效 设备连接: 使用前请确保键鼠模拟器设备已正确连接 检查设备 VID 和 PID 是否正确配置 字符串编码: 如果中文出现乱码，使用 HKMSetMode 改变输出字符串编码 默认使用剪贴板粘贴方式输出字符串，速度快且不受输入法影响 线程安全: 请确保设备操作在同一线程中进行，避免并发访问 \uD83D\uDD17 相关链接 SKSimulator 官方文档 请认真阅读官网的指南 与 API参考 使用SKSimulator的开发框架 - WeChatAuto.SDK 注意: 本项目仅用于学习和合法用途，请勿用于任何非法活动。"
  }
}