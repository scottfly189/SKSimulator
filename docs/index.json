{
  "api/SKM.Config.html": {
    "href": "api/SKM.Config.html",
    "title": "Class Config | SKSimulator键鼠模拟器",
    "summary": "Class Config Namespace SKM Assembly SKSimulator.dll 参数配置类 public static class Config Inheritance object Config Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties KMDeivicePID 键鼠模拟器设备PID public static int KMDeivicePID { get; set; } Property Value int KMDeiviceVID 键鼠模拟器设备VID public static int KMDeiviceVID { get; set; } Property Value int KMMouseMoveMode 鼠标移动模式 public static int KMMouseMoveMode { get; set; } Property Value int KMOffsetOfClick 点击偏移量,单位像素 为了避免每次点击都点击到同一个位置，可以设置一个偏移量，实际点击位置为点击位置减去偏移量的一个随机值 public static int KMOffsetOfClick { get; set; } Property Value int KMOutputStringType 输出字符串编码类型,默认使用剪贴板粘贴输出字符串。优点是输出字符多时速度更快且不受输入法影响 public static int KMOutputStringType { get; set; } Property Value int KMVerifyUserData 键鼠模拟器校验数据 public static string KMVerifyUserData { get; set; } Property Value string ProcessDpiAwareness 进程DPI感知值,如果使用库的应用已经设置DPI感知，此参数无效。 0: 不设置,进程对DPI完全不知晓，按逻辑像素绘制，可能会出现点击不准确的情况。 1: PROCESS_SYSTEM_DPI_AWARE 默认值,进程只根据主显示器DPI绘制，DPI感知生效。 2: PROCESS_PER_MONITOR_DPI_AWARE，进程根据每个显示器DPI绘制,DPI感知生效。 public static int ProcessDpiAwareness { get; set; } Property Value int"
  },
  "api/SKM.DpiAwareness.html": {
    "href": "api/SKM.DpiAwareness.html",
    "title": "Class DpiAwareness | SKSimulator键鼠模拟器",
    "summary": "Class DpiAwareness Namespace SKM Assembly SKSimulator.dll public static class DpiAwareness Inheritance object DpiAwareness Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods SetProcessDPIAware() 设置进程DPI感知(旧方法) 注意：此方法必须在任何窗口创建之前调用，如果使用库的应用已经设置DPI感知，调用此方法无效 public static extern bool SetProcessDPIAware() Returns bool 是否成功 SetProcessDpiAwareness(int) 设置进程DPI感知,如果使用库的应用已经设置DPI感知，此方法无效。 此方法必须在任何窗口创建之前调用 public static void SetProcessDpiAwareness(int processDpiAwareness) Parameters processDpiAwareness int Exceptions Exception SetProcessDpiAwarenessContext(int) 设置进程DPI感知(新方法) 注意：此方法必须在任何窗口创建之前调用 public static extern int SetProcessDpiAwarenessContext(int value) Parameters value int DPI感知值 Returns int 是否成功"
  },
  "api/SKM.KMSimulatorService.html": {
    "href": "api/SKM.KMSimulatorService.html",
    "title": "Class KMSimulatorService | SKSimulator键鼠模拟器",
    "summary": "Class KMSimulatorService Namespace SKM Assembly SKSimulator.dll 键鼠模拟器服务 封装skm.dll的函数，提供键鼠模拟器服务 x64环境需要复制x64\\skm.dll，x86环境需要复制x86\\skm.dll到当前目录，意思是：x64环境需要使用x64\\skm.dll，x86环境需要使用x86\\skm.dll 本服务类会自动根据当前环境复制DLL到当前目录，可以无感知使用 public static class KMSimulatorService Inheritance object KMSimulatorService Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties DeviceData public static nint DeviceData { get; } Property Value nint Methods CloseDevice() 关闭设备 public static void CloseDevice() Init(int, int, string) public static void Init(int deviceVID, int devicePID, string verifyUserData) Parameters deviceVID int devicePID int verifyUserData string IsDeviceOpen() 判断设备是否打开 public static bool IsDeviceOpen() Returns bool 是否打开 OpenDevice(uint) 打开设备 public static void OpenDevice(uint deviceID) Parameters deviceID uint 设备ID SearchDevice(int, int) 搜索设备 public static uint SearchDevice(int deviceVID, int devicePID) Parameters deviceVID int 设备VID devicePID int 设备PID Returns uint 设备ID"
  },
  "api/SKM.SkmCore.html": {
    "href": "api/SKM.SkmCore.html",
    "title": "Class SkmCore | SKSimulator键鼠模拟器",
    "summary": "Class SkmCore Namespace SKM Assembly SKSimulator.dll 注意: x86 和 x64 的 dll 是不同的，需要根据实际情况选择 x86 的 dll 是 x86\\skm.dll，x64 的 dll 是 x64\\skm.dll 使用 KMSimulatorService 服务类可以无感知使用，会自动根据当前环境复制 DLL 到当前目录 具体 KMSimulatorService 类使用请参考 KMSimulatorService public class SkmCore Inheritance object SkmCore Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods HKMCheckPressedKeysCS(uint) public static string HKMCheckPressedKeysCS(uint Flags) Parameters Flags uint Returns string HKMClose(nint) public static extern bool HKMClose(nint HKMData) Parameters HKMData nint Returns bool HKMDelayRnd(nint, uint, uint) public static extern bool HKMDelayRnd(nint HKMData, uint MinTime, uint MaxTime) Parameters HKMData nint MinTime uint MaxTime uint Returns bool HKMEnableOSMouseAccelerate(bool, bool) public static extern bool HKMEnableOSMouseAccelerate(bool Enable, bool Save) Parameters Enable bool Save bool Returns bool HKMGetCursorPos(nint, ref int, ref int) public static extern bool HKMGetCursorPos(nint HKMData, ref int X, ref int Y) Parameters HKMData nint X int Y int Returns bool HKMGetCursorPos2(nint) public static extern uint HKMGetCursorPos2(nint HKMData) Parameters HKMData nint Returns uint HKMGetDevInfo(nint, uint, bool) public static extern uint HKMGetDevInfo(nint HKMData, uint Index, bool Mouse) Parameters HKMData nint Index uint Mouse bool Returns uint HKMGetDevString(nint, uint, bool, ref uint) public static extern nint HKMGetDevString(nint HKMData, uint Index, bool Mouse, ref uint Length) Parameters HKMData nint Index uint Mouse bool Length uint Returns nint HKMGetDevStringCS(nint, uint, bool) public static string HKMGetDevStringCS(nint HKMData, uint Index, bool Mouse) Parameters HKMData nint Index uint Mouse bool Returns string HKMGetKeyboardLEDState(nint, uint) public static extern bool HKMGetKeyboardLEDState(nint HKMData, uint Index) Parameters HKMData nint Index uint Returns bool HKMGetKeyboardMode(nint) public static extern uint HKMGetKeyboardMode(nint HKMData) Parameters HKMData nint Returns uint HKMGetMouseMode(nint) public static extern uint HKMGetMouseMode(nint HKMData) Parameters HKMData nint Returns uint HKMGetOSMouseSpeed() public static extern int HKMGetOSMouseSpeed() Returns int HKMGetSerialNumber(nint, bool) public static extern uint HKMGetSerialNumber(nint HKMData, bool Mouse) Parameters HKMData nint Mouse bool Returns uint HKMIsKeyBusy(nint) public static extern bool HKMIsKeyBusy(nint HKMData) Parameters HKMData nint Returns bool HKMIsKeyDown(nint, string) public static extern bool HKMIsKeyDown(nint HKMData, string KeyName) Parameters HKMData nint KeyName string Returns bool HKMIsMouseBusy(nint) public static extern bool HKMIsMouseBusy(nint HKMData) Parameters HKMData nint Returns bool HKMIsMouseButtonDown(nint, uint) public static extern bool HKMIsMouseButtonDown(nint HKMData, uint Index) Parameters HKMData nint Index uint Returns bool HKMIsOSMouseAccelerateEnabled() public static extern bool HKMIsOSMouseAccelerateEnabled() Returns bool HKMIsOpen(nint, uint) public static extern bool HKMIsOpen(nint HKMData, uint Flags) Parameters HKMData nint Flags uint Returns bool HKMKeyDown(nint, string) public static extern bool HKMKeyDown(nint HKMData, string KeyName) Parameters HKMData nint KeyName string Returns bool HKMKeyPress(nint, string) public static extern bool HKMKeyPress(nint HKMData, string KeyName) Parameters HKMData nint KeyName string Returns bool HKMKeyUp(nint, string) public static extern bool HKMKeyUp(nint HKMData, string KeyName) Parameters HKMData nint KeyName string Returns bool HKMLeftClick(nint) public static extern bool HKMLeftClick(nint HKMData) Parameters HKMData nint Returns bool HKMLeftDoubleClick(nint) public static extern bool HKMLeftDoubleClick(nint HKMData) Parameters HKMData nint Returns bool HKMLeftDown(nint) public static extern bool HKMLeftDown(nint HKMData) Parameters HKMData nint Returns bool HKMLeftUp(nint) public static extern bool HKMLeftUp(nint HKMData) Parameters HKMData nint Returns bool HKMMiddleClick(nint) public static extern bool HKMMiddleClick(nint HKMData) Parameters HKMData nint Returns bool HKMMiddleDoubleClick(nint) public static extern bool HKMMiddleDoubleClick(nint HKMData) Parameters HKMData nint Returns bool HKMMiddleDown(nint) public static extern bool HKMMiddleDown(nint HKMData) Parameters HKMData nint Returns bool HKMMiddleUp(nint) public static extern bool HKMMiddleUp(nint HKMData) Parameters HKMData nint Returns bool HKMMouseWheel(nint, int) public static extern bool HKMMouseWheel(nint HKMData, int Count) Parameters HKMData nint Count int Returns bool HKMMouseWheelP(nint, int) public static extern bool HKMMouseWheelP(nint HKMData, int Count) Parameters HKMData nint Count int Returns bool HKMMoveR(nint, int, int) public static extern bool HKMMoveR(nint HKMData, int X, int Y) Parameters HKMData nint X int Y int Returns bool HKMMoveR2(nint, int, int) public static extern bool HKMMoveR2(nint HKMData, int X, int Y) Parameters HKMData nint X int Y int Returns bool HKMMoveRP(nint, int, int) public static extern bool HKMMoveRP(nint HKMData, int X, int Y) Parameters HKMData nint X int Y int Returns bool HKMMoveTo(nint, int, int) public static extern bool HKMMoveTo(nint HKMData, int X, int Y) Parameters HKMData nint X int Y int Returns bool HKMOpen(uint, uint) public static extern nint HKMOpen(uint DeviceId, uint DpiMode) Parameters DeviceId uint DpiMode uint Returns nint HKMOpen2(uint, uint, uint) public static extern nint HKMOpen2(uint DeviceId1, uint DeviceId2, uint DpiMode) Parameters DeviceId1 uint DeviceId2 uint DpiMode uint Returns nint HKMOutputString(nint, string) public static extern bool HKMOutputString(nint HKMData, string Str) Parameters HKMData nint Str string Returns bool HKMReleaseKeyboard(nint) public static extern bool HKMReleaseKeyboard(nint HKMData) Parameters HKMData nint Returns bool HKMReleaseMouse(nint) public static extern bool HKMReleaseMouse(nint HKMData) Parameters HKMData nint Returns bool HKMRightClick(nint) public static extern bool HKMRightClick(nint HKMData) Parameters HKMData nint Returns bool HKMRightDoubleClick(nint) public static extern bool HKMRightDoubleClick(nint HKMData) Parameters HKMData nint Returns bool HKMRightDown(nint) public static extern bool HKMRightDown(nint HKMData) Parameters HKMData nint Returns bool HKMRightUp(nint) public static extern bool HKMRightUp(nint HKMData) Parameters HKMData nint Returns bool HKMSearchDevice(uint, uint, uint) public static extern uint HKMSearchDevice(uint Vid, uint Pid, uint DeviceType) Parameters Vid uint Pid uint DeviceType uint Returns uint HKMSearchDevice2(uint, uint, uint, uint) public static extern uint HKMSearchDevice2(uint Vid, uint Pid, uint SN, uint DeviceType) Parameters Vid uint Pid uint SN uint DeviceType uint Returns uint HKMSearchDeviceAll(uint, uint, uint) public static extern nint HKMSearchDeviceAll(uint Vid, uint Pid, uint DeviceType) Parameters Vid uint Pid uint DeviceType uint Returns nint HKMSetAbsMouseScrnRes(nint, int, int) public static extern bool HKMSetAbsMouseScrnRes(nint HKMData, int Width, int Height) Parameters HKMData nint Width int Height int Returns bool HKMSetKeyInterval(nint, uint, uint) public static extern bool HKMSetKeyInterval(nint HKMData, uint MinTime, uint MaxTime) Parameters HKMData nint MinTime uint MaxTime uint Returns bool HKMSetLightMode(nint, uint, bool) public static extern bool HKMSetLightMode(nint HKMData, uint Mode, bool Mouse) Parameters HKMData nint Mode uint Mouse bool Returns bool HKMSetMode(nint, uint, uint) public static extern bool HKMSetMode(nint HKMData, uint Index, uint Mode) Parameters HKMData nint Index uint Mode uint Returns bool HKMSetMouseInterval(nint, uint, uint) public static extern bool HKMSetMouseInterval(nint HKMData, uint MinTime, uint MaxTime) Parameters HKMData nint MinTime uint MaxTime uint Returns bool HKMSetMouseMoveTimeout(nint, uint) public static extern bool HKMSetMouseMoveTimeout(nint HKMData, uint Timeout) Parameters HKMData nint Timeout uint Returns bool HKMSetMousePosMaxOffset(nint, uint) public static extern bool HKMSetMousePosMaxOffset(nint HKMData, uint dwOffset) Parameters HKMData nint dwOffset uint Returns bool HKMSetMousePosPrecision(nint, uint) public static extern bool HKMSetMousePosPrecision(nint HKMData, uint Precision) Parameters HKMData nint Precision uint Returns bool HKMSetMouseSpeed(nint, uint) public static extern bool HKMSetMouseSpeed(nint HKMData, uint MouseSpeed) Parameters HKMData nint MouseSpeed uint Returns bool HKMSetOSMouseSpeed(int, bool) public static extern bool HKMSetOSMouseSpeed(int Speed, bool Save) Parameters Speed int Save bool Returns bool HKMSetResetMode(nint, uint, bool) public static extern bool HKMSetResetMode(nint HKMData, uint Mode, bool Mouse) Parameters HKMData nint Mode uint Mouse bool Returns bool HKMSetResetTime(nint, uint, bool) public static extern bool HKMSetResetTime(nint HKMData, uint Time, bool Mouse) Parameters HKMData nint Time uint Mouse bool Returns bool HKMVerifyUserData(nint, string, bool) public static extern bool HKMVerifyUserData(nint HKMData, string Str, bool Mouse) Parameters HKMData nint Str string Mouse bool Returns bool HKMVerifyUserData2(nint, string, bool) public static extern uint HKMVerifyUserData2(nint HKMData, string Str, bool Mouse) Parameters HKMData nint Str string Mouse bool Returns uint HKMXBtn1Click(nint) public static extern bool HKMXBtn1Click(nint HKMData) Parameters HKMData nint Returns bool HKMXBtn1DoubleClick(nint) public static extern bool HKMXBtn1DoubleClick(nint HKMData) Parameters HKMData nint Returns bool HKMXBtn1Down(nint) public static extern bool HKMXBtn1Down(nint HKMData) Parameters HKMData nint Returns bool HKMXBtn1Up(nint) public static extern bool HKMXBtn1Up(nint HKMData) Parameters HKMData nint Returns bool HKMXBtn2Click(nint) public static extern bool HKMXBtn2Click(nint HKMData) Parameters HKMData nint Returns bool HKMXBtn2DoubleClick(nint) public static extern bool HKMXBtn2DoubleClick(nint HKMData) Parameters HKMData nint Returns bool HKMXBtn2Down(nint) public static extern bool HKMXBtn2Down(nint HKMData) Parameters HKMData nint Returns bool HKMXBtn2Up(nint) public static extern bool HKMXBtn2Up(nint HKMData) Parameters HKMData nint Returns bool"
  },
  "api/SKM.html": {
    "href": "api/SKM.html",
    "title": "Namespace SKM | SKSimulator键鼠模拟器",
    "summary": "Namespace SKM Classes Config 参数配置类 DpiAwareness KMSimulatorService 键鼠模拟器服务 封装skm.dll的函数，提供键鼠模拟器服务 x64环境需要复制x64\\skm.dll，x86环境需要复制x86\\skm.dll到当前目录，意思是：x64环境需要使用x64\\skm.dll，x86环境需要使用x86\\skm.dll 本服务类会自动根据当前环境复制DLL到当前目录，可以无感知使用 SkmCore 注意: x86 和 x64 的 dll 是不同的，需要根据实际情况选择 x86 的 dll 是 x86\\skm.dll，x64 的 dll 是 x64\\skm.dll 使用 KMSimulatorService 服务类可以无感知使用，会自动根据当前环境复制 DLL 到当前目录 具体 KMSimulatorService 类使用请参考 KMSimulatorService"
  },
  "content/architecture-overview.html": {
    "href": "content/architecture-overview.html",
    "title": "Introduction | SKSimulator键鼠模拟器",
    "summary": "Introduction"
  },
  "content/contact-operation.html": {
    "href": "content/contact-operation.html",
    "title": "通讯录管理 | SKSimulator键鼠模拟器",
    "summary": "通讯录管理 获取通讯录所有好友 方法签名: public List<string> GetAllFriends() 返回通讯中所有好友昵称 定位好友 在通讯录中定位好友，即使好友在UI界面中可见 方法签名: public bool LocateFriend(string friendName) 其中: friendName: 好友昵称 返回: 如果找到好友，返回True,否则为False 获取所有公众号 在通讯录中获取所有公众号列表 方法签名: public List<string> GetAllOfficialAccount() 获取所有待添加好友 当有其他人申请你为好友时，会在待添加好友列表中 方法签名: public List<string> GetAllWillAddFriends(string keyWord = null) 其中: keyWord: 关键词，待添加好友是否设定此关键词，如果设置了关键词，则仅返回添加 关键词 的好友 返回： 返回待添加的好友列表 通过新好友 方法签名: public List<string> PassedAllNewFriend(string keyWord = null, string suffix = null, string label = null) 其中: keyWord: 可选，如果设置关键字，则通过包含关键字的新好友，如果没有设置，则通过所有新好友 suffix: 可选，如果设置后缀，则在添加好友时，会在好友昵称后添加后缀,方便分类管理 label: 可选，如果设置标签，则在添加好友时，会为此好友设置标签，方便分类管理 移除好友 方法签名: public bool RemoveFriend(string nickName) nickName: 好友昵称 添加好友 在已知好友微信号或者电话号码的情况下添加好 注意：不能添加太频繁，否则可能会触发微信的风控机制，导致加好友失败 public List<(string friendName, bool isSuccess, string errMessage)> AddFriends(List<string> friendNames, string label = \"\") 其中: friendNames: 微信号/手机号列表 label: 可选，用户标签，如果设置了label,则在添加用户的时候设置标签,方便分类管理 添加好友二 在已知好友微信号或者电话号码的情况下添加好 注意：不能添加太频繁，否则可能会触发微信的风控机制，导致加好友失败 public bool AddFriend(string friendName, string label = \"\") 其中: friendNames: 微信号/手机号列表 label: 可选，用户标签，如果设置了label,则在添加用户的时候设置标签,方便分类管理"
  },
  "content/conversation-operation.html": {
    "href": "content/conversation-operation.html",
    "title": "会话管理 | SKSimulator键鼠模拟器",
    "summary": "会话管理 获取所有可见会话列表 获取会话列表可见会话,会话信息包含：会话名称、会话类型、会话状态、会话时间、会话未读消息数、会话头像等信息 方法签名: public List<Conversation> GetVisibleConversations() 返回: List<Conversation>,具体Conversation类包含会话的一些信息，请参考: Conversation类 获取会话列表所有名称 获取会话列表所有会话的名称,考虑到效率，只返回名称列表 方法签名: public List<string> GetAllConversations() 返回：所有会话列表的标题 定位会话 定位会话的作用：可以将会话列表滚动到指定会话的位置，使指定会话可见 方法签名: public bool LocateConversation(string title) 其中: title: 会话标题 点击会话 点击会话,使会话窗口获取焦点 方法签名: public void ClickConversation(string title) 其中: title: 会话标题 点击第一个会话 点击第一个会话,使第一个会话窗口获取焦点 方法签名: public void ClickFirstConversation() 双击会话 双击会话,弹出子窗口,使会话窗口获取焦点 方法签名: public void DoubleClickConversation(string title) 其中: title: 会话标题 获取可见会话标题 方法签名: public List<string> GetVisibleConversationTitles() 返回会话标题列表 查找并打开会话 查找并打开会话,如果找到，则打开好友或者群聊窗口 方法签名: public WeAutoCommon.Models.Result FindAndOpenFriendOrGroup(string who) 其中: who: 好友或者群聊昵称"
  },
  "content/faq.html": {
    "href": "content/faq.html",
    "title": "FAQ | SKSimulator键鼠模拟器",
    "summary": "FAQ 你提，我来回答\uD83D\uDE0A"
  },
  "content/friend-circle-operation.html": {
    "href": "content/friend-circle-operation.html",
    "title": "朋友圈管理 | SKSimulator键鼠模拟器",
    "summary": "朋友圈管理 打开朋友圈 方法定义: public void OpenMoments() 通过主窗口打开朋友圈窗口 判断朋友圈是否打开 方法定义: public bool IsMomentsOpen() 判断朋友圈打开状态，如果朋友圈窗口存在，则返回True, 否则返回False 获取朋友圈内容列表 方法定义: public List<MomentItem> GetMomentsList(int count = 20) 其中: count: 可选，鼠标滚动次数,一次滚动5行，由于朋友圈动态可能过长，所以做了此限制 返回: 一个MomentItem对象列表，MomentItem包含了朋友圈动态所需要的信息，具体请参考: MomentItem类 静默模式获取朋友圈内容列表 静默模式意味着在朋友圈窗口不置顶的情况下获取内容 方法定义: public List<MomentItem> GetMomentsListSilence() 返回: 一个MomentItem对象列表，MomentItem包含了朋友圈动态所需要的信息，具体请参考: MomentItem类 刷新朋友圈 方法定义: public void RefreshMomentsList() 点击朋友圈窗口的刷新按钮 朋友圈点赞 对设定的好友的朋友圈动态进行自动点赞 方法定义: public void LikeMoments(OneOf<string, string[]> nickNames) 其中: nickNames: 好友昵称或好友昵称列表 回复朋友圈动态 方法定义: public void ReplyMoments(OneOf<string, string[]> nickNames, string replyContent) 其中: nickNames: 好友昵称或好友昵称列表 replyContent: 回复内容"
  },
  "content/glossary.html": {
    "href": "content/glossary.html",
    "title": "认识POM对象 | SKSimulator键鼠模拟器",
    "summary": "认识POM对象 WeChatAuto.SDK 采用页面对象模型（POM）设计理念，将微信的各类操作场景进行了模块化、清晰的组件封装。你只需要理解这些 POM 对象及其所对应的微信界面组件，就能便捷地调用其公开方法和属性，大幅简化功能开发和后期维护。如果你熟悉 WeChatAuto.SDK 的 POM 组件体系，基本上已经掌握了 60% 的核心用法\uD83D\uDE0A。 \uD83D\uDE80 WeChatAuto.SDK POM 组件结构图 基本上每个POM组件抽象并封装了微信的某个部位 \uD83C\uDF81 WeChatAuto.SDK的页面组件介绍 \uD83C\uDF88\uD83C\uDF88 基础术语 主窗口： 微信聊天的主窗口 子窗口： 双击会话打开的弹出窗口 1. WeChatClientFactory组件 本组件无UI WeChatClientFactory组件是非常重要的核心组件，负责多微信客户端的统一管理。SDK初始化后，可以通过依赖注入获取该组件。随后，可以通过WeChatClientFactory组件获取具体的微信客户端（WeChatClient）实例，实现对不同微信账号的操作和管理。 // 初始化WeAutomation服务 var serviceProvider = WeAutomation.Initialize(options => { options.DebugMode = true; //开启调试模式，调试模式会在获得焦点时边框高亮，生产环境建议关闭 //options.EnableRecordVideo = true; //开启录制视频功能，录制的视频会保存在项目的运行目录下的Videos文件夹中 }); //获取到WeChatClientFactory using var clientFactory = serviceProvider.GetRequiredService<WeChatClientFactory>(); 由于WeChatClientFactory是以Singletion的方式加入依赖注入容器中，所以我们可以很方便的通过构造器注入等方式获取到它,具体请参考WeChatClientFactory WeChatClientFactory组件的Initialize()方法的参数WeChatConfig配置对象说明： 属性名 说明 CaptureUIPath 进行截图操作时，捕获UI界面保存的路径 默认保存到当前目录下的Capture文件夹,可以修改为其他路径 ListenInterval 群或者好友消息监听的时间间隔,单位：秒，默认5秒监听一次 MomentsListenInterval 朋友圈监听的时间间隔,单位：秒，默认10秒监听一次 NewUserListenerInterval 监听新用户的时间间隔，单位：秒，默认5秒监听一次 MonitorSubWinInterval 监听子窗口时间间隔，单位秒,默认5秒监听一次 DebugMode 是否启用调试模式，启用了调试模式可以在运行时看到按钮高亮，默认false EnableRecordVideo 是否启用视频录制，如果启用，可以录制整个自动化运行过程，默认false TargetVideoPath 自定义视频录制文件保存位置，默认保存到当前目录下的Video文件夹,可以修改为其他路径 EnableMouseKeyboardSimulator 是否启用鼠标键盘模拟器,启用后，键盘鼠标操作会通过模拟器进行操作，而不是通过windows automation进行操作,注意：需要购买键鼠模拟器，并在此处启用 KMDeiviceVID 配置键鼠模拟器设备VID KMDeivicePID 配置键鼠模拟器设备PID KMVerifyUserData 配置键鼠模拟器用户校验数据 KMOutputStringType 配置键鼠模拟器输出字符串编码类型,默认使用剪贴板粘贴输出字符串。优点是输出字符多时速度更快且不受输入法影响 KMMouseMoveMode 配置键鼠模拟器鼠标移动模式 KMOffsetOfClick 点击偏移量,单位像素,为了避免每次点击都点击到同一个位置，可以设置一个偏移量，实际点击位置为点击位置减去偏移量的一个随机值 ProcessDpiAwareness 进程DPI感知值,如果使用库的应用已经设置DPI感知，此参数无效，可设置参数为:0: 不设置,进程对DPI完全不知晓，按逻辑像素绘制，可能会出现点击不准确的情况。1: PROCESS_SYSTEM_DPI_AWARE 默认值,进程只根据主显示器DPI绘制，DPI感知生效。 2: PROCESS_PER_MONITOR_DPI_AWARE，进程根据每个显示器DPI绘制,DPI感知生效。 更具体的了解WeChatConfig配置对象，请参考: WeChatConfig配置对象 2. WeChatClient组件 WeChatClient组件代表一个微信客户端对象，这是整个POM组件体系的入口，只有先获取WebChatClient,再通过WebChatClient获取POM的其他组件 本组件无UI 通过WeChatClientFactory获取到WeChatClient对象 WeChatClient对象使用委托模式转发调用其他各个组件的方法：如：消息管理，监听等，让客户端只需与 WeChatClient 交互，而不需要了解底层组件,当然更详细的API调用，还得了解WeChatClient包装的其他组件 具体请参见WeChatClient类 3. WeChatNotifyIcon组件 本组件封装并抽象了微信在任务栏中的托盘图标（NotifyIcon），如下图所示： 可以通过WeChatClient.WxNotifyIcon属性获取到WeChatNotifyIcon对象，并执行方法; 更详细请参考WeChatNotifyIcon组件 4. WeChatMainWindow组件 本组件封装并抽象了微信窗口，封装的微信窗口，包含工具栏、导航栏、搜索、会话列表、通讯录、聊天窗口等 可以通过WeChatClient组件的WxMainWindow属性获取到微信客户端所属的WeChatMainWindow组件对象 WeChatMainWindow组件可以调用丰富的属性与方法,WeChatMainWindow组件也是各个其他组件的入口 对应微信部位如下图所示: 具体请参考WeChatMainWindow组件 5. Toolbar组件 本组件封装并抽象了微信右上角的工具栏，可以通过Toolbar组件设置置顶/取消置顶、最小化、最大化、关闭等操作,对应微信的位置如下: 具体请参考Toolbar组件 6. Navigation组件 本组件封装并抽象了微信左侧的菜单，可以通过Navigation组件点击左侧的聊天、通讯录、收藏等按钮,对应微信位置如下: 具体请参考Navigation组件 7. Moments组件 本组件封装并抽象了微信朋友圈，可以提供打开朋友圈、获取朋友圈内容列表、刷新朋友圈等操作，对应微信的位置如下： 具体请参考Moments组件 8. ChatContent组件 ChatContent组件是很重要的一个组件，最主要通过它得到ChatHeader、ChatBody等组件，对应微信的位置如下： 主窗口与子窗口都有ChatContent组件 具体请参考ChatContent组件 9. ChatHeader组件 ChatHeader组件提供了获取主窗口与子窗口的聊天对象的标题，对应微信的位置如下： 主窗口与子窗口都有ChatHeader组件 具体请参考ChatHeader组件 10. ChatBody组件 ChatBody组件封装了聊天体，可以用它来获取聊天列表MessageBubbleList与Sender组件,对应微信的位置如下所示： 主窗口与子窗口都有ChatBody组件 具体请参考ChatBody组件 11. MessageBubbleList组件与MessageBubble组件 MessageBubbleList组件封装了一个聊天列表，一个MessageBubbleList包含多个MessageBubble 一个MessageBubble组件封装了一条消息，包括发送消息人，消息内容,时间等信息 对应的微信的位置如下： 主窗口与子窗口都有MessageBubbleList组件与MessageBubble组件 具体请参考MessageBubbleList组件与MessageBubble组件 12. Sender组件 Sender组件封装了一个发送器，可以用它来发送文本消息、Emoji字符串、文件等，对应的微信内容如下: 主窗口与子窗口都有Sender组件 具体请参考Sender组件 13. ConversationList会话列表组件与Conversation组件 ConversationList组件封装了一个会话列表，Conversation封装了一个会话，对应微信位置如下： 只有主窗口才有ConversationList会话列表组件与Conversation组件 具体请参考ConversationList会话列表组件与Conversation组件 14. Search组件 Search组件封装了微信搜索框,对应微信位置如下: 只有主窗口才有Search组件 具体请参考Search组件 15. SubWinList组件 SubWinList组件封装了所有的子窗口的操作，如：启动子窗口，关闭子窗口，监听子窗口关闭再打开等，对应位置如下: 可以通过WeChatMainWindow组件得到SubWinList组件 具体请参考SubWinList组件 16. SubWin组件 SubWinList组件封装了一个子窗口,子窗口为双击会话弹出的窗口，可以通过SubWinList获取ChatContent,通过ChatContent获取到MessageBubbleList与Sender等子组件，对应位置如下: 具体请参考SubWin组件"
  },
  "content/group-operation.html": {
    "href": "content/group-operation.html",
    "title": "| SKSimulator键鼠模拟器",
    "summary": "群聊管理 群聊管理仅适用于聊天室进行管理,可以实现获取群聊成员对象，自动加好友等操作 可以通过WeChatClient对象调用下面方法,当然也可以通过WeChatMainWindow类来调用。 基础术语 自有群：自己担任群主的群聊 外部群：他人为群主且自己为成员的群聊 获取群聊成员列表 方法签名: public async Task<List<string>> GetChatGroupMemberList(string groupName) 其中: groupName: 聊天室昵称 返回: List<string>: 聊天室所有成员的昵称列表 是否是群聊成员 方法签名： public async Task<bool> IsChatGroupMember(string groupName, string memberName) 其中： groupName: 群聊昵称 memberName: 群聊成员 返回： 指定的memberName是否在群聊成员列表中 测试群是否是自有群 方法签名: public async Task<bool> IsOwnerChatGroup(string groupName) 如果自己是群主，则返回:True 获取群主 方法签名: public async Task<string> GetGroupOwner(string groupName) 返回群聊groupName的群主名称 清空群聊历史聊天记录 方法签名: public async Task ClearChatGroupHistory(string groupName) 其中： groupName: 群聊名称 退出群聊 方法签名: public async Task QuitChatGroup(string groupName) 其中： groupName: 群聊名称 设置消息免打扰 方法签名: public ChatResponse SetMessageWithoutInterruption(string groupName, bool isMessageWithoutInterruption = true) 其中: groupName: 群聊名称 isMessageWithoutInterruption: 是否消息免打扰,默认是True:消息免打扰,False:取消消息免打扰 保存到通讯录 方法签名: public ChatResponse SetSaveToAddress(string groupName, bool isSaveToAddress = true) 其中： groupName: 群聊名称 isSaveToAddress: 是否保存到通讯录,默认是True:保存,False:取消保存 设置聊天置顶 方法签名: public ChatResponse SetChatTop(string groupName, bool isTop = true) 其中： groupName: 群聊名称 isTop: 是否置顶,默认是True:置顶,False:取消置顶 改变自有群群备注 修改自有群备注（当然...我们也修改不了外部群的备注） 方法签名: public ChatResponse ChangeOwnerChatGroupMemo(string groupName, string newMemo) 其中: groupName: 群聊名称 newMemo: 新备注 返回: 请参考ChatResponse类 修改群名 修改群名，适用于自有群群名 方法签名: public ChatResponse ChangeOwnerChatGroupName(string oldGroupName, string newGroupName) 其中: oldGroupName: 旧群名称 newGroupName: 新群名称 更新群聊公告 更新群聊公告，仅适用于自有群的群聊公告更新 方法签名: public async Task<ChatResponse> UpdateGroupNotice(string groupName, string groupNotice) 其中: groupName: 群聊名称 groupNotice: 群聊公告 创建群聊 创建群聊，如果存在，则打开它，如果群聊不存在，则创建一个新群聊 方法签名: public ChatResponse CreateOrUpdateOwnerChatGroup(string groupName, OneOf<string, string[]> memberName) 其中： groupName: 群聊名称 memberName: 要拉入群聊的成员，即好友昵称列表 检查群聊是否存在 检查群聊或者好友是否存在 方法签名: public bool CheckFriendExist(string friendName, bool doubleClick = false) 其中： friendName: 好友昵称，也可以是群聊昵称 doubleClick: 如果好友存在，是否在会话窗口中打开它，即：是否双击它打开子窗口 添加群聊成员 添加群聊成员,将好友拉到群中 方法签名: public async Task<ChatResponse> AddOwnerChatGroupMember(string groupName, OneOf<string, string[]> memberName) 其中： groupName: 群聊名称 memberName: 可以是单个好友，也可以是一个好友昵称列表 删除群聊 删除群聊，适用于自有群,与退出群聊不同，退出群聊是退出群聊，删除群聊会删除自有群的所有好友，然后退出群聊 public async Task<ChatResponse> DeleteOwnerChatGroup(string groupName) groupName: 群聊名称 移除群聊成员 移除群聊成员,适用于自有群 public async Task<ChatResponse> RemoveOwnerChatGroupMember(string groupName, OneOf<string, string[]> memberName) 其中: groupName: 群聊名称 memberName: 成员名称 邀请群聊成员 适用在外部群邀请好友入群 方法定义: public async Task<ChatResponse> InviteChatGroupMember(string groupName, OneOf<string, string[]> memberName, string helloText = \"\") 其中： groupName: 群聊名称 memberName: 成员名称 helloText: 给群主打招呼的文本 群中加好友 添加群聊里面的指定好友为自己的好友,适用于从外部群中添加所有好友为自己的好友 注意：此方法容易引起微信风控退出，为了安全建议用下面分页添加好友的方法： 分页添加好友 方法定义: public async Task<ChatResponse> AddChatGroupMemberToFriends(string groupName, OneOf<string, string[]> memberName, int intervalSecond = 5, string helloText = \"\", string label = \"\") 其中： groupName: 群聊名称 memberName: 要添加的群里的好友列表,可以单个好友，也可以设置多个 intervalSecond: 间隔时间，增加每个好友时的间隔时间 helloText: 给要增加的好友打招呼的方式 label: 好友标签，方便分类管理 群里加好友二 添加群聊里面的所有好友为自己的好友,适用于从外部群中添加所有好友为自己的好友 方法定义: public async Task<ChatResponse> AddAllChatGroupMemberToFriends(string groupName, List<string> exceptList = null, int intervalSecond = 3, string helloText = \"\", string label = \"\", int pageNo = 1, int pageSize = 15) 其中: groupName: 群聊名称 exceptList: 可选，排除的好友列表，如：群主本来就在自己通讯录，可以设置排除 intervalSecond: 间隔时间，添加每个好友时的间隔时间 helloText: 给好友打招呼的方式 label: 为新增好友设置的标签，方便分类管理 pageNo: 起始页码,从1开始,如果从0开始，表示不使用分页，全部添加好友，但容易触发微信风控机制，建议使用分页添加 pageSize: 每页数量,为添加的每页好友的数量 群里加好友三 添加群聊里面的所有好友为自己的好友,适用于从外部群中添加所有好友为自己的好友 注意：此方法容易触发微信风控机制，建议使用分页添加，并使用键鼠模拟器的方式添加好友。 方法定义: public async Task<ChatResponse> AddAllChatGroupMemberToFriends(string groupName, Action<AddGroupMemberOptions> options) 其中： groupName: 群聊名称 options: 添加群聊成员为好友的选项,具体请参考:AddGroupMemberOptions类"
  },
  "content/listen-message.html": {
    "href": "content/listen-message.html",
    "title": "监听管理 | SKSimulator键鼠模拟器",
    "summary": "监听管理 \uD83D\uDE80 消息监听 添加消息监听 适用于聊天（与好友或者在群聊中)时监听用户发来的消息,需要提供一个回调函数，当消息到达时，会自动调用这个回调函数 可以通过WeChatClinet对象调用AddMessageListener方法,当然也可以通过WeChatMainWindow类来调用此方法 方法定义: public async Task AddMessageListener(string nickName, Action<MessageContext> callBack) 其中： nickName: 好友昵称 callBack: 回调函数,由用户提供,参数请参考MessageContext类 移除消息听听 添加消息监听会启动一个System.Threading.Timer来监听消息，所以如果不需要这个监听的时候，请移除监听 方法定义: public void StopMessageListener(string nickName) 其中: nickName: 好友昵称 \uD83D\uDE80 新好友申请监听 如果添加了新好友申请监听，当有新好友添加你的微信时，会自动监听到好友申请，并且执行你定义的逻辑 可以通过WeChatClinet对象调用方法,当然也可以通过WeChatMainWindow类来调用。 自动通过新好友申请 用户只需提供一个回调函数，当检测到有新好友申请时，系统会自动通过申请，并在通过后调用用户的回调函数。 可通过WeChatClient对象调用AddNewFriendAutoPassedListener方法。 方法定义: public void AddNewFriendAutoPassedListener(Action<List<string>> callBack, string keyWord = null, string suffix = null, string label = null) 参数说明： callBack：自定义回调函数，当有新好友添加成功时被调用 keyWord：可选, 设定关键词；仅当好友申请内容包含此关键词时才自动通过。若为null，则所有好友申请均会被自动通过 suffix：可选，自动通过时在新好友昵称后添加的后缀，便于管理分类 label：可选，自动通过时为新好友打上的微信标签，方便分类管理 移转新用户申请监听 方法定义: StopNewUserListener() \uD83D\uDE80 添加朋友圈监听 开启朋友圈监听后，可以自动获取到好友在朋友圈发布的动态，适合实现自动点赞、自动评论等功能。 可以通过WeChatClinet对象调用方法,当然也可以通过WeChatMainWindow类来调用。 方法签名： public void AddMomentsListener(OneOf<string, List<string>> nickNameOrNickNames, bool autoLike = true, Action<MomentsContext, IServiceProvider> action = null) 参数说明： nickNameOrNickNames：单个好友昵称或昵称列表，表示需要监听哪些好友的朋友圈动态。 autoLike：是否自动点赞，默认为 true。如需关闭自动点赞可设置为 false。 action：当监听到朋友圈新动态时自动调用的回调函数，用户可自定义处理逻辑。回调参数包括： MomentsContext：包含点赞、评论等操作方法。 IServiceProvider：依赖注入服务提供器，可用于获取自定义 Service，方便扩展自己的业务逻辑。 MomentsContext详解 MomentsContext为处理朋友圈动态提供的上下文对象,方便与LLM集成 属性与方法如下： 获取历史回复列表 方法签名: public List<ReplyItem> GetHistoryReplyItems() 返回List<ReplyItem>列表，具体ReplyItem类请参考：ReplyItem 获取朋友圈动态内容项 方法鉴名： public MomentItem GetMomentItem() 返回MomentItem对象，可以通过此对象获取发送朋友圈动态的好友昵称、内容、时间、评论列表、我是否点赞等信息,具体请参考:MomentItem 获取朋友圈动态内容 方法鉴名: public string GetMomentContent() 此内容可以做为大模型提供上下文信息。 获取朋友圈动态列表项唯一标识 方法定义： public string GetMomentKey() 返回朋友圈动态列表的唯一标识,此标识可以做为大模型提供上下文信息,如：朋友圈动态记录唯一标识。 是否我是最后一个回复的人 方法定义： public bool IsMyEndReply() 确认我是否是最后的回复人，供大模型自动回复朋友圈动态时参考 是否朋友动态的回复列表中包含我的回复 方法定义: public bool IsIncludeMyReply() 回复列表中是否包含我的回复，供大模型自动回复时参考。 是否我点赞过朋友圈动态 方法定义: public bool IsMyLiked() 此朋友圈动态是否我点赞过，供模型自动回复时参考 执行回复朋友圈动态 方法定义: public void DoReply(string replyContent) 为此条朋友圈动态进行回复 其中: replyContent: 回复内容 执行朋友圈动态点赞 方法定义： public void DoLike() 为此条朋友圈动态进行点赞，如果已经点赞，则不作操作."
  },
  "content/mcp-server-client.html": {
    "href": "content/mcp-server-client.html",
    "title": "MCP Server 使用指南 | SKSimulator键鼠模拟器",
    "summary": "MCP Server 使用指南 \uD83C\uDF89 MCP Server介绍 MCP（Model Context Protocol，模型上下文协议）是专为大语言模型（LLM, Large Language Model）打造的服务端组件，其核心能力在于为LLM动态提供丰富的可调用工具、外部资源、结构化提示词等高阶能力，使模型不仅能处理自然语言对话，更可灵活组合、调用各类外接能力，显著扩展大模型的应用边界。 MCP Server 的主要优势体现在： 一站式工具与资源调度：集中管理并安全开放各类内置或第三方API、插件、知识库，让模型可按需动态调用和组合。 结构化提示词与上下文封装：支持先进的 Prompt 工程和多轮上下文封装，使LLM能灵活切换任务模式及对外部信息的引用。 多模态和可追踪交互：不仅支持文本，还兼容图像、表格等多模态输入输出，同时自动记录与分析上下文流程，便于追踪和溯源。 标准化与易集成：MCP基于开放协议设计，兼容各类LLM平台（如个人Agent、企业Bot、插件市场等），快速集成，一处接入全局赋能。 如果你在构建大语言模型驱动的应用或平台，MCP Server 能让你的LLM随时具备调用工具、获取知识、使用专业提示词等超强能力，是新一代智能体与大模型协作的基础设施。 \uD83D\uDE80 WeChatAuto.SDK MCP示例 - 以Vscode为例 本文主要演示vscode使用mcp server,你也可以在自己的应用加入mcp client代码，通过mcp client来调用LLM来操作微信桌面客户端. 步骤一： 打开mcp.json 在项目的根目录运行code .打开vscode编辑器 在vscode中打开.vscode --> 打开mcp.json文件,如下图所示： 步骤二：修改mcp.json { \"servers\": { \"wechat_mcp_server\": { \"type\": \"stdio\", \"command\": \"dotnet\", \"args\": [ \"run\", \"--project\", \"你的WeChatAuto.MCP.csproj路径，如：D:\\\\repo\\\\wxauto.net\\\\WeChatAuto.SDK\\\\src\\\\WeChatAuto.MCP\\\\WeChatAuto.MCP.csproj\" ] } } } 步骤三：修改好mcp.json后，运行mcp server,如下图所示 启动后，如下图所示，你会看到MCP Server公布出来的工具与资源： 步骤四: 打开github copilot chat，如下图所示: 步骤五：在 github copilot chat 对话框中直接输入你想自动化微信的指令，例如： 请帮我给微信好友:AI.net发送消息: Hello world!! 具体详细使用请参考微软相关文档"
  },
  "content/message-operation.html": {
    "href": "content/message-operation.html",
    "title": "消息管理 | SKSimulator键鼠模拟器",
    "summary": "消息管理 注：教程中\"好友昵称\"与\"好友昵称\"具有同样的语义 \uD83D\uDE80 消息发送模型 WeChatAuto.SDK支持两种消息发送模型: 单独发送消息 适用于单发、群发、转发等简单聊天场景。 聊天过程消息回复 适用于在聊天过程中进行消息回复，特别适合接入大模型实现自动回复的场景。 \uD83D\uDE0A 单独发送消息 具体请参考源码: 项目根目录\\Examples\\demo03 1. 发送文本消息 可以通过WeChatClient类或者WeChatMainWindow类发送消息,或者通过窗口类WeChatMainWindow获得Sender对象来发送消息 方法定义 public async Task SendWho(string who, string message, OneOf<string, string[]> atUser = default, bool isOpenChat = true) 其中： who: 好友昵称，可以是好友或者群昵称 message: 消息内容 atUser: 被@的好友昵称，可以单个好友，也可以是一个好友数组，适用群聊中@好友 isOpenChat: 是否打开子聊天窗口,默认是True:打开,False:不打开 示例代码: /*** * 示例三 - 消息管理演示 */ using WeChatAuto.Services; using WeChatAuto.Components; using Microsoft.Extensions.DependencyInjection; var serviceProvider = WeAutomation.Initialize(options => { options.DebugMode = true; }); using var clientFactory = serviceProvider.GetRequiredService<WeChatClientFactory>(); var client = clientFactory.GetWeChatClient(\"Alex\"); //发送消息给AI.Net好友昵称，请修改成自己的好友昵称 await client.SendWho(\"AI.Net\", \"你好，世界！\"); //发送消息给群聊\"测试11\"，并@好友:123321 await client.SendWho(\"测试11\", \"你好，世界！\", \"123321\"); //发送消息给群聊\"测试11\"，并@好友:123321,Alex await client.SendWho(\"测试11\",\"你好，世界！\",new string[]{\"123321\",\"Alex\"}); 2. 发送Emoji表情 注：Emoji 表情可以单独发送，也可以包含在文字消息中，其他用法同上面的发送文本消息 方法定义: public async Task SendEmoji(string who, OneOf<int, string> emoji, OneOf<string, string[]> atUser = default, bool isOpenChat = false) 其中: who: 好友昵称，可以是好友或者群昵称 emoji: 可以是表情名称或者描述或者索引,具体索引或者描述等请参考下面的Emoji表 atUser: 被@的好友昵称，可以单个好友，也可以是一个好友数组，适用群聊中@好友 isOpenChat: 是否打开子聊天窗口,默认是True:打开,False:不打开 Emoji表参考 Emoji表按打开微信聊天窗口的“表情”从左到右，从上到下进行索引排序 索引 (index) 描述 (desc) 表情名 (value) 1 微笑 [微笑] 2 撇嘴 [撇嘴] 3 色色表情 [色] 4 发呆 [发呆] 5 得意 [得意] 6 流泪 [流泪] 7 害羞 [害羞] 8 闭嘴 [闭嘴] 9 睡 [睡] 10 大哭 [大哭] 11 尴尬 [尴尬] 12 发怒 [发怒] 13 调皮 [调皮] 14 呲牙 [呲牙] 15 惊讶 [惊讶] 16 难过 [难过] 17 囧 [囧] 18 抓狂 [抓狂] 19 吐 [吐] 20 偷笑 [偷笑] 21 愉快 [愉快] 22 白眼 [白眼] 23 傲慢 [傲慢] 24 困 [困] 25 惊恐 [惊恐] 26 憨笑 [憨笑] 27 悠闲 [悠闲] 28 咒骂 [咒骂] 29 疑问 [疑问] 30 嘘 [嘘] 31 晕 [晕] 32 衰 [衰] 33 骷髅 [骷髅] 34 敲打 [敲打] 35 再见 [再见] 36 擦汗 [擦汗] 37 抠鼻 [抠鼻] 38 鼓掌 [鼓掌] 39 坏笑 [坏笑] 40 右哼哼 [右哼哼] 41 鄙视 [鄙视] 42 委屈 [委屈] 43 快哭了 [快哭了] 44 阴险 [阴险] 45 亲亲 [亲亲] 46 可怜 [可怜] 47 笑脸 [笑脸] 48 生病 [生病] 49 脸红 [脸红] 50 破涕为笑 [破涕为笑] 51 恐惧 [恐惧] 52 失望 [失望] 53 无语 [无语] 54 嘿哈 [嘿哈] 55 捂脸 [捂脸] 56 奸笑 [奸笑] 57 机智 [机智] 58 皱眉 [皱眉] 59 耶 [耶] 60 吃瓜 [吃瓜] 61 加油 [加油] 62 汗 [汗] 63 天啊 [天啊] 64 嗯嗯嗯 [Emm] 65 社会社会 [社会社会] 66 旺柴 [旺柴] 67 好的 [好的] 68 打脸 [打脸] 69 哇 [哇] 70 翻白眼 [翻白眼] 71 666 [666] 72 让我看看 [让我看看] 73 叹气 [叹气] 74 苦涩 [苦涩] 75 裂开 [裂开] 76 嘴唇 [嘴唇] 77 爱心 [爱心] 78 心碎 [心碎] 79 拥抱 [拥抱] 80 强 [强] 81 弱 [弱] 82 握手 [握手] 83 胜利 [胜利] 84 抱拳 [抱拳] 85 勾引 [勾引] 86 拳头 [拳头] 87 OK [OK] 88 合十 [合十] 89 啤酒 [啤酒] 90 咖啡 [咖啡] 91 蛋糕 [蛋糕] 92 玫瑰 [玫瑰] 93 凋谢 [凋谢] 94 菜刀 [菜刀] 95 炸弹 [炸弹] 96 便便 [便便] 97 月亮 [月亮] 98 太阳 [太阳] 99 庆祝 [庆祝] 100 礼物 [礼物] 101 红包 [红包] 102 發 [發] 103 福 [福] 104 烟花 [烟花] 105 爆竹 [爆竹] 106 猪头 [猪头] 107 跳跳 [跳跳] 108 发抖 [发抖] 109 转圈 [转圈] 3. 发起语音聊天,适用于单个好友 给单个好友发起语音聊天，如果是群聊，请使用下面的SendVoiceChats方法,参考群聊中发起语音聊天 方法定义 public void SendVoiceChat(string who, bool isOpenChat = true) 其中: who: 好友昵称，非群聊昵称 isOpenChat: 是否打开子聊天窗口,默认是True:打开,False:不打开 4. 群聊中发起语音聊天 在聊天室中发起语音聊天，需要指定聊天人 方法定义 public void SendVoiceChats(string groupName, string[] whos, bool isOpenChat = true) => WxMainWindow.SendVoiceChats(groupName, whos, isOpenChat); 其中: groupName: 群聊名称 whos: 好友昵称列表,好友昵称必须在群聊中 isOpenChat: 是否打开子聊天窗口,默认是True:打开,False:不打开 5. 发起直播 群聊中发起直播，单个好友没有直播功能 方法定义 public void SendLiveStreaming(string groupName, bool isOpenChat = false) 其中: groupName: 群聊名称 isOpenChat: 是否打开子聊天窗口,默认是True:打开,False:不打开 6. 获取当前聊天窗口的标题 获取主窗口当前聊天的窗口 方法定义: public string GetCurrentChatTitle() 7. 给指定好友发送(多个)文件 方法定义 public async Task SendFile(string who, OneOf<string, string[]> files, bool isOpenChat = false) 其中： who: 好友昵称 files: 文件路径,可以是单个文件路径，也可以是多个文件路径，要求文件实际在磁盘中存在 isOpenChat: 是否打开子聊天窗口,默认是True:打开,False:不打开 8. 发送消息给多个好友(批量发送) 给多个好友（包括群聊）批量发送同样的消息 方法定义: public async Task SendWhos(string[] whos, string message, OneOf<string, string[]> atUser = default, bool isOpenChat = true) 其中： whos: 好友昵称列表 message: 消息内容 atUser: 被@的用户,最主要用于群聊中@人,可以是一个用户，也可以是多个用户，如果是自有群，可以@所有人，也可以@单个用户，微信不支持他人群@所有人 isOpenChat: 是否打开子聊天窗口,默认是True:打开,False:不打开 9. 给多个好友发送文件 方法定义: public async Task SendFiles(string[] whos, OneOf<string, string[]> files, bool isOpenChat = false) 其中： whos: 好友昵称列表 files: 文件路径,可以是单个文件路径，也可以是多个文件路径，要求文件实际在磁盘中存在 isOpenChat: 是否打开子聊天窗口,默认是True:打开,False:不打开 10. 获取用户所有消息列表 由于聊天内容比较长，需要指定聊天页数,如果指定为-1，则获取所有气泡,有可能被卡死 方法定义: public List<ChatSimpleMessage> GetChatAllHistory(string who,int pageCount = 10) 其中： who: 好友昵称，可以是好友，也可以是群聊名称 pageCount: 获取的气泡数量，默认是10页,可以指定获取的页数，如果指定为-1，则获取所有气泡 11. 转发消息给好友 转发指定的消息数量给好友 方法定义: public async Task<bool> ForwardMessage(string fromWho, string toWho, int rowCount = 5) 其中： fromWho: 转发消息的来源,可以是好友昵称，也可以是群聊名称 toWho: 转发消息的接收者,可以是好友昵称，也可以是群聊名称 rowCount: 转发消息的行数 \uD83D\uDE01 聊天过程消息回复 聊天过程回复最主要使用在监听中，一些使用场景如下： 监听与好友（或者群聊）聊天过程，如果有好友发来消息，自动化回复; 监听有新好友加你，WeChatAuto.SDK自动化加上好友后，自动给新好友发送一些消息，自动回复消息等。 考虑如下模板代码: var builder = Host.CreateApplicationBuilder(args); WeAutomation.Initialize(builder.Services, options => { }); var serviceProvider = builder.Services.BuildServiceProvider(); var clientFactory = serviceProvider.GetRequiredService<WeChatClientFactory>(); var client = clientFactory.GetWeChatClient(\"Alex\"); //监听群 \"测试11\" 聊天，并做自动回复. await client.AddMessageListener(\"测试11\", (messageContext) => { //在这里messageContext使用回复、转发消息 }); var app = builder.Build(); await app.RunAsync(); 从上面代码可以看出：监听提供注入messageContext进行消息操作，而messageContext是一个MessageContext类 1. 获取我的微信昵称 messageContext.OwnerNickName 2. 获取新消息列表 messageContext.NewMessages 返回List<MessageBubble>列表,具体MessageBubble消息类请参考MessageBubble 3. 获取所有消息列表 messageContext.AllMessages 返回List<MessageBubble>列表,具体MessageBubble消息类请参考MessageBubble 4. 获取Sender发送对象 messageContext.Sender 返回Sender对象，可以用此Sender对象发送消息等，具体Sender类请参考Sender类 5. 获取WeChatClient对象 messageContext.OwnerClient 获取到WeChatClient对象后，可以参照前面的单独发送消息的各个方法进行消息操作,具体WeChatClient类请参照:WeChatClient类 所以： 虽然是消息上下文，也获得了单独发送消息各个能力 6. 获取WeChatClientFactory客户端工厂对象 messageContext.SystemClientFactory SystemClientFactory属性最主要用于多微信客户端场合，获取到WeChatClientFactory对象后，可以通过WeChatClientFactory对象向本机任意微信客户端发送消息,是不是很Cool!\uD83D\uDE0A 具体WeChatClientFactory类请参照：WeChatClientFactory类 7. 获取IServiceProvider依赖注入提供者 messageContext.ServiceProvider 这是一个非常实用的功能。通过IServiceProvider，你可以灵活获取到在依赖注入容器中注册的任何服务类对象，以便在消息处理过程中调用，例如大模型自动回复服务、数据库上下文等。messageContext.ServiceProvider 相当于连接你的自定义业务逻辑和框架的桥梁，大大提升扩展性和可维护性。 8. 获取新消息方法 messageContext.GetNewMessages() 返回List<MessageBubble>列表,具体MessageBubble消息类请参考MessageBubble 9. 获取最近所有消息方法 messageContext.GetAllMessages() 返回List<MessageBubble>列表,具体MessageBubble消息类请参考MessageBubble 10. 获取最后几条消息 messageContext.GetLastMessages(int count) 返回List<MessageBubble>列表,具体MessageBubble消息类请参考MessageBubble 11. 获取LLM上下文消息 messageContext.GetLLMContextMessages 返回List 对象，以作为发给LLM的历史上下文列表 12. 获取LLM上下文消息(重载) messageContext.GetLLMContextMessagesTuple 返回List<(string who, string message)>元组列表,可以通过List<(string who, string message)>元组列表自己组建LLM的历史上下文 13. 是否被人拍一拍 messageContext.IsBeTap() 返回True或者False,确定自己是否被人拍一拍 14. 是否被其他人@我 messageContext.IsBeAt() 确定是否被其他人@我 15. 获取被@的消息列表 messageContext.MessageBubbleIsBeAt() 获取被@的消息气泡列表,可以通过消息列表获取谁@了我，内容是什么 16. 我的消息是否被引用 messageContext.IsBeReferenced 返回True或者False,确定自己消息被人引用 17. 获取我的被引用的消息列表 messageContext.MessageBubbleIsReferenced() 返回List<MessageBubble>列表,具体MessageBubble消息类请参考MessageBubble 18. 获取引用中我自己的消息列表 messageContext.MessageBubbleIsReferencing() 返回List<MessageBubble>列表,具体MessageBubble消息类请参考MessageBubble 19. 发送文字消息 messageContext.SendMessage(string message, List<string> atUserList = null) 其中: message: 消息内容 atUserList: 被@的用户列表 其他更多操作请参见MessageContext类： MessageContext类"
  },
  "content/quick-start.html": {
    "href": "content/quick-start.html",
    "title": "\uD83D\uDC49 快速开始 | SKSimulator键鼠模拟器",
    "summary": "\uD83D\uDC49 快速开始 \uD83C\uDF88 前置条件 本SDK基于Windows的UI Automation开发，所以仅支持Windows 操作系统，并且需要将项目的TargetFramework修改成:目标框架-windows,如你在.net8下使用，请将TargetFramework修改成net8.0-windows; .NET Framework 4.8+ 或 .NET 6.0+ (Windows)，支持.NET的框架有:net48;net481;net6.0-windows; net7.0-windows;net8.0-windows;net9.0-windows;net10.0-windows; 微信 PC 客户端已安装并运行,本 SDK 基于微信 PC 客户端(版本号:3.9.12.55)的 UI 结构开发，不同版本可能存在兼容性问题。 \uD83C\uDF89 安装 通过 NuGet 安装： dotnet add package WeChatAuto.SDK \uD83C\uDF89 WeChatAuto.SDK的初始化 WeChatAuto.SDK的初始化的通用格式为: WeAutomation.Initialize(...,Action<WeChatConfig> options) 但根据应用依赖注入引入的情况分两种情况： 应用没有启用依赖注入 此种情况需要自行引入dotnet add package Microsoft.Extensions.DependencyInjection包,这样应用也有了依赖注入容器,并且根据情况初始化WeChatConfig配置对象，如下所示: // 初始化WeAutomation服务 var serviceProvider = WeAutomation.Initialize(options => { options.DebugMode = true; //开启调试模式，调试模式会在获得焦点时边框高亮，生产环境建议关闭 //options.EnableRecordVideo = true; //开启录制视频功能，录制的视频会保存在项目的运行目录下的Videos文件夹中 }); using var clientFactory = serviceProvider.GetRequiredService<WeChatClientFactory>(); ...下面是更多代码 注意：如果应用没有启用依赖注入，clientFactory的生命周期需要自行负责，或者应用退出的时候显式clientFactory.Dispose(),或者将clientFactory放入using {}代码块中自动释放 应用启用了依赖注入框架 此种情况，需要在应用Services.BuildServiceProvider()前进行初始化,并将应用的Services做为初始化的第一个参数，这样本SDK就集成在应用的依赖注入框架中，如下所示: using Microsoft.Extensions.Hosting; using WeChatAuto.Services; using WeChatAuto.Components; using Microsoft.Extensions.DependencyInjection; using Microsoft.Extensions.Logging; var builder = Host.CreateApplicationBuilder(args); WeAutomation.Initialize(builder.Services, options => { //开启调试模式，调试模式会在获得焦点时边框高亮，生产环境建议关闭 options.DebugMode = true; //开启录制视频功能，录制的视频会保存在项目的运行目录下的Videos文件夹中 //options.EnableRecordVideo = true; }); //这里注入自已的服务（或者对象），如LLM服务等 builder.Services.AddSingleton<LLMService>(); var serviceProvider = builder.Services.BuildServiceProvider(); var clientFactory = serviceProvider.GetRequiredService<WeChatClientFactory>(); ...更多代码 await builder.Build().RunAsync(); ... 此种方式的初始化无须管理clientFactory的生命周期 \uD83D\uDE0A 基本使用 示例一: 给好友（或群聊昵称）发送消息： 源码请参见: 项目根目录\\Examples\\demo01 步骤一：新建项目，如下所示: dotnet new console -n demo01 步骤二：将demo01.csproj项目文件的net10.0修改成net10.0-windows,如下所示: <PropertyGroup> <OutputType>Exe</OutputType> <TargetFramework>net10.0-windows</TargetFramework> <ImplicitUsings>enable</ImplicitUsings> <Nullable>enable</Nullable> </PropertyGroup> 步骤三：安装依赖 dotnet add package WeChatAuto.SDK dotnet add package Microsoft.Extensions.DependencyInjection 步骤四：项目demo01的Program.cs修改成如下： using Microsoft.Extensions.DependencyInjection; using WeChatAuto.Components; using WeChatAuto.Services; // 初始化WeAutomation服务 var serviceProvider = WeAutomation.Initialize(options => { options.DebugMode = true; //开启调试模式，调试模式会在获得焦点时边框高亮，生产环境建议关闭 //options.EnableRecordVideo = true; //开启录制视频功能，录制的视频会保存在项目的运行目录下的Videos文件夹中 }); using var clientFactory = serviceProvider.GetRequiredService<WeChatClientFactory>(); Console.WriteLine($\"当前客户端打开的微信客户端为：{string.Join(\",\", clientFactory.GetWeChatClientNames())}，共计{clientFactory.GetWeChatClientNames().Count}个微信客户端。\"); //获取当前打开的微信客户端名称列表 var clientNames = clientFactory.GetWeChatClientNames(); //获取第一个微信客户端 var wxClient = clientFactory.GetWeChatClient(clientNames.First()); //通过微信客户端发送消息给好友昵称AI.Net，测试时请把AI.Net修改成自己的好友昵称 wxClient?.SendWho(\"AI.Net\",\"你好，欢迎使用AI.Net微信自动化框架！\"); 注意： 本项目仅支持 Windows 系统，请务必将项目文件的 TargetFramework 设置为 netxx.0-windows（如 net10.0-windows），否则编译时会出现警告。后续不再赘述。 如果是手动管理WeChatClientFactory,请在应用结束时运行clientFactory.Dispose(),或者像示例代码一样将代码放入using块自动释放,如果把WeChatAuto.SDK加入您的依赖注入容器，则不存在此问题。 WeAutomation.Initialize()方法有两个重载，分别适用于：加入外部依赖注入与使用内部依赖注入。 示例二 - 演示监听好友（或者群聊昵称）的消息,使用消息上下文获取消息并回复,并且还演示了如何通过依赖注入获取消息上下文的注入对象,执行自己的业务逻辑： 源码请参见: 项目根目录\\Examples\\demo02 前置步骤：安装依赖 dotnet add package WeChatAuto.SDK dotnet add package Microsoft.Extensions.Hosting 将项目demo02的Program.cs修改成如下 using Microsoft.Extensions.Hosting; using WeChatAuto.Services; using WeChatAuto.Components; using Microsoft.Extensions.DependencyInjection; using Microsoft.Extensions.Logging; var builder = Host.CreateApplicationBuilder(args); WeAutomation.Initialize(builder.Services, options => { //开启调试模式，调试模式会在获得焦点时边框高亮，生产环境建议关闭 options.DebugMode = true; //开启录制视频功能，录制的视频会保存在项目的运行目录下的Videos文件夹中 //options.EnableRecordVideo = true; }); //这里注入自已的服务（或者对象），如LLM服务等 builder.Services.AddSingleton<LLMService>(); var serviceProvider = builder.Services.BuildServiceProvider(); var clientFactory = serviceProvider.GetRequiredService<WeChatClientFactory>(); // 得到名称为\"Alex\"的微信客户端实例，测试时请将AI.net替换为你自己的微信昵称 var client = clientFactory.GetWeChatClient(\"Alex\"); // 监听微信群测试11 await client.AddMessageListener(\"测试11\", (messageContext) => { var index = 0; //打印收到最新消息 foreach (var message in messageContext.NewMessages) { index++; Console.WriteLine($\"收到消息：{index}：{message.ToString()}\"); Console.WriteLine($\"收到消息：{index}：{message.Who}：{message.MessageContent}\"); } //打印收到所有消息的后十条 var allMessages = messageContext.AllMessages.Skip(messageContext.AllMessages.Count - 10).ToList(); index = 0; foreach (var message in allMessages) { index++; Console.WriteLine($\"...收到所有消息的后10条之第{index}条：{message.Who}：{message.MessageContent}\"); Console.WriteLine($\".................详细之第{index}条：{message.ToString()}\"); } //是否有人@我 if (messageContext.IsBeAt()) { var messageBubble = messageContext.MessageBubbleIsBeAt().FirstOrDefault(); if (messageBubble != null) { messageContext.SendMessage(\"我被@了！！！！我马上就回复你！！！！\", new List<string> { messageBubble.Who }); } else { messageContext.SendMessage(\"我被@了！！！！我马上就回复你！！！！\"); } } //是否有人引用了我的消息 if (messageContext.IsBeReferenced()) { messageContext.SendMessage(\"我被引用了！！！！\"); } //是否有人拍了拍我 if (messageContext.IsBeTap()) { messageContext.SendMessage(\"我被拍一拍了[微笑]！！！！\"); } if (!messageContext.IsBeAt() && !messageContext.IsBeReferenced() && !messageContext.IsBeTap()) { //回复消息，这里可以引入大模型自动回复 messageContext.SendMessage($\"我收到了{messageContext.NewMessages.FirstOrDefault()?.Who}的消息：{messageContext.NewMessages.FirstOrDefault()?.MessageContent}\"); } //可以通过注入的服务容器获取你注入的服务实例，然后调用你的业务逻辑,一般都是LLM的自动回复逻辑 var llmService = messageContext.ServiceProvider.GetRequiredService<LLMService>(); llmService.DoSomething(); }); var app = builder.Build(); await app.RunAsync(); /// <summary> /// 一个包含LLM服务的Service类，用于注入到MessageContext中 /// </summary> public class LLMService { private ILogger<LLMService> _logger; public LLMService(ILogger<LLMService> logger) { _logger = logger; } public void DoSomething() { _logger.LogInformation(\"这里是你注入的服务实例，可以在这里编写你的业务逻辑 \"); } } 前置步骤跟Demo01一致,可以通过messageContext对象执行各种操作,也可以通过messageContext对象获得依赖注入容器，获取自己的对象，执行自己的业务逻辑; 示例三 - MCP Server的使用 - 以vscode为例讲解 进入源码的.vscode\\mcp.json,修改配置如下: { \"servers\": { \"wechat_mcp_server\": { \"type\": \"stdio\", \"command\": \"dotnet\", \"args\": [ \"run\", \"--project\", \"改成你的WeChatAuto.MCP.csproj的路径\" ] } } } 在mcp.json页面点击\"Start\"按钮启动mcp server 启动GitHub Copilot Chat,在Chat页提问: 请帮我给微信好友:AI.Net发送消息：Hello world!"
  },
  "device.html": {
    "href": "device.html",
    "title": "键鼠模拟器购买 | SKSimulator键鼠模拟器",
    "summary": "键鼠模拟器购买 本 SDK 需要配合专用的键鼠模拟器硬件设备使用。该硬件设备通过 USB HID 接口连接，能够以硬件级别模拟键盘和鼠标输入，具有极高的隐蔽性和安全性。 \uD83D\uDCE6 产品信息 设备类型: USB HID 键鼠模拟器 接口类型: USB 2.0/3.0 支持系统: Windows 操作系统 设备 VID: 0x2612 可定制 设备 PID: 0x1701 可定制 用户加密: 可定制,方便用户分发与授权管理 驱动方式: 免驱动（即插即用） \uD83D\uDCF8 键鼠模拟器实拍照片 \uD83D\uDCB3 购买流程 1. 联系购买 购买价格: 129元/个 如需购买键鼠模拟器硬件设备，请通过以下方式联系： 温馨提示：添加好友时请备注“键鼠”，否则可能无法通过好友申请。 2. 购买时凭证 购买时请提供以下信息，以便我们为您提供准确的产品和售后服务： 购买数量: 需要购买的数量 收货地址: 详细的收货地址和联系方式 用途说明: 简要说明使用场景（用于技术开发、自动化测试等） 发票需求: 暂不支持开具发票。如您有特殊发票需求，请提前沟通，我们将尽力协助，但目前仅支持个人/非企业用户购买。 4. 发货信息 发货时间: 目前每台键鼠模拟器均为定制化小批量生产，确保每台设备质量可靠。一般情况下，订单确认后将在 6 个工作日内安排发货，如果需求数量大，或者遇特殊情况（如材料短缺、生产排单等）会及时与您沟通协商具体发货时间，请您谅解,如无法接受此发货周期，请谨慎下单。 物流方式: 顺丰快递 / 其他快递（根据地区选择） 包装说明: 每个设备独立包装，含防静电袋和保护材料 ✅ 质量保证 质保政策 质保期限: 自收货之日起 3 个月 质保范围: 设备硬件故障（非人为损坏） 无法正常识别或连接 功能异常（按键/鼠标模拟失效） 质保方式: 免费维修或更换 承担往返运费 提供技术支持 技术支持 技术支持内容: SDK 集成指导 设备使用问题解答 代码示例提供 常见问题排查 支持渠道: GitHub Issues 技术文档 在线咨询 ⚠️ 注意事宜 购买前注意事项 兼容性确认 确认您的开发环境为 Windows 系统 确认项目需要硬件级别的键鼠模拟功能 了解 SDK 的使用要求和限制 数量规划 根据实际项目需求确定购买数量 建议先购买少量进行测试验证 批量采购可享受优惠价格（请咨询） 技术支持 购买前可先查看项目文档和示例代码 如有技术问题，建议先查阅文档或提交 Issue 购买后我们将提供更详细的技术支持 使用注意事项 设备连接 首次使用前，请确保设备正确插入 USB 接口 建议使用 USB 2.0 或更高版本接口 避免使用 USB 延长线或集线器（可能影响稳定性） 驱动安装 设备为免驱动设计，Windows 系统会自动识别 如系统无法识别，请检查 USB 接口和线缆 可在设备管理器中查看设备状态 SDK 配置 购买后，您将获得对应的设备 VID/PID 和校验数据 请妥善保管校验数据，用于 SDK 初始化 按照 README.md 中的说明进行配置 合法使用 本设备仅用于合法的自动化测试、开发调试等场景 请勿用于任何违法违规活动 使用本设备产生的任何法律后果由使用者自行承担 设备维护 避免设备受潮、高温或强烈震动 不使用时建议妥善保管 定期检查 USB 接口和线缆的完好性 重要提示: 本设备为专用硬件，需要配合本 SDK 使用 购买前请确认您的使用场景和需求 如有疑问，建议先咨询后再购买"
  },
  "index.html": {
    "href": "index.html",
    "title": "SKSimulator - 键鼠模拟器 SDK | SKSimulator键鼠模拟器",
    "summary": "SKSimulator - 键鼠模拟器 SDK 键鼠模拟器是一类专用硬件设备，能够通过底层信号模拟真实的键盘与鼠标输入操作。相比于传统的 PostMessage、SendInput、SetWindowsHookEx 等 Windows API 注入方式，软件模拟常常会被安全监控系统检测到（如获取窗口焦点、输入来源判别、消息钩子分析等），从而被微信、企业微信等主流应用识别为自动化行为，存在较高的风控和封号风险。而采用硬件级别的信号注入，输入几乎等同于真实用户操作，不会留下易被检测的 API 调用特征，具备极高的隐蔽性和安全性，非常适合需要高安全性的自动化场景。 \uD83D\uDD04 工作原理对比 ┌─────────────────────────────────────────────────────────────────────────┐ │ 传统软件模拟方式 │ └─────────────────────────────────────────────────────────────────────────┘ 应用程序 │ ├─→ PostMessage/SendInput/SetWindowsHookEx │ │ │ ├─→ Windows API 调用 │ │ │ │ │ ├─→ ⚠️ 可被检测特征 │ │ │ ├─ 窗口焦点获取 │ │ │ ├─ 输入来源判别 │ │ │ └─ 消息钩子分析 │ │ │ │ │ └─→ 安全监控系统 │ │ │ │ │ └─→ ❌ 识别为自动化行为 │ │ └─→ 风控/封号风险 │ │ └─────────┴─────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────────────┐ │ 硬件键鼠模拟器方式 │ └─────────────────────────────────────────────────────────────────────────┘ 应用程序 │ ├─→ SKSimulator SDK │ │ │ ├─→ skm.dll (硬件驱动) │ │ │ │ │ └─→ \uD83D\uDD0C 硬件设备 (USB HID) │ │ │ │ │ ├─→ ✅ 底层信号注入 │ │ │ ├─ 硬件级别输入 │ │ │ ├─ 无 API 调用特征 │ │ │ └─ 等同于真实用户操作 │ │ │ │ │ └─→ 操作系统 │ │ │ │ │ └─→ ✅ 识别为真实输入 │ │ └─→ 高隐蔽性/安全性 │ │ └─────────┴─────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────────────┐ │ 对比总结 │ ├─────────────────────────────────────────────────────────────────────────┤ │ │ │ 传统软件模拟 │ 硬件键鼠模拟器 │ │ ───────────── │ ───────────── │ │ ❌ 易被检测 │ ✅ 高隐蔽性 │ │ ❌ API 调用特征 │ ✅ 无 API 特征 │ │ ❌ 风控风险高 │ ✅ 安全性高 │ │ ❌ 可能被封号 │ ✅ 等同于真实操作 │ │ │ └─────────────────────────────────────────────────────────────────────────┘ 本 SDK 采用 C# 实现，完整支持键盘和鼠标的各类操作，同时兼容 x86 与 x64 架构，自动管理 DLL 加载和依赖，无需手动干预。 \uD83D\uDC49 本键鼠模拟器也支持 C++ 集成。 x86 架构：包含并链接 x86/HKM.h 和 x86/hkm.lib x64 架构：包含并链接 x64/HKM.h 和 x64/hkm.lib 只需在对应平台下引入相关头文件和库文件，即可方便调用 DLL 接口。 ✨ 功能特性 \uD83C\uDFAF 完整的键鼠模拟功能 - 支持键盘按键、鼠标移动、点击等所有操作 \uD83D\uDD27 自动 DLL 管理 - 自动根据运行环境（x86/x64）复制对应的 DLL 文件 \uD83D\uDCDD 字符串输出 - 支持 Unicode 和 ANSI 编码，支持中文输入 \uD83D\uDDB1️ DPI 感知 - 支持多显示器 DPI 感知，确保坐标精度 ⚙️ 灵活配置 - 可配置设备参数、输出模式、鼠标移动模式等 \uD83D\uDD12 设备验证 - 内置校验机制，提升安全性，支持硬件分发与授权管理 ⏱️ 随机延时 - 内置随机延时功能，模拟更真实的操作 \uD83D\uDCCB 系统要求 Windows 操作系统 键鼠模拟器硬件设备。本 SDK 需要配合硬件使用，如需硬件设备，请联系我 \uD83D\uDE80 快速开始 1. 克隆项目 git clone https://github.com/scottfly189/SKSimulator.git cd src 2. 配置设备参数 在 Config.cs 中配置您的设备参数： public static int KMDeiviceVID { get; set; } = 0x2612; // 设备 VID public static int KMDeivicePID { get; set; } = 0x1701; // 设备 PID public static string KMVerifyUserData { get; set; } = \"您的校验数据\"; 3. 准备 DLL 文件 确保 x64/skm.dll 和 x86/skm.dll 文件存在于项目中。项目会自动根据运行环境复制对应的 DLL。 如下所示将 DLL 文件包含在项目中： <!-- 复制DLL到输出目录 --> <ItemGroup> <None Include=\"x64\\skm.dll\"> <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory> <TargetPath>x64\\skm.dll</TargetPath> </None> <None Include=\"x86\\skm.dll\"> <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory> <TargetPath>x86\\skm.dll</TargetPath> </None> </ItemGroup> 4. 编译运行 dotnet build dotnet run \uD83D\uDCD6 使用示例 基本使用 using SKM; // 初始化设备 KMSimulatorService.Init(Config.KMDeiviceVID, Config.KMDeivicePID, Config.KMVerifyUserData); IntPtr HKMData = KMSimulatorService.DeviceData; // 设置模式（输出字符串编码、鼠标移动模式） SkmCore.HKMSetMode(HKMData, 4, 4); // 键盘操作示例 SkmCore.HKMKeyPress(HKMData, \"WIN+E\"); // 组合键 SkmCore.HKMKeyDown(HKMData, \"Ctrl\"); SkmCore.HKMKeyPress(HKMData, \"A\"); SkmCore.HKMKeyUp(HKMData, \"Ctrl\"); // 输出字符串（支持中文） SkmCore.HKMOutputString(HKMData, \"ABC中文，可以打成全部是中文吗？\"); SkmCore.HKMOutputString(HKMData, \"\\r\\n换行测试，Hello World!\"); // 鼠标操作示例 SkmCore.HKMMoveR(HKMData, 100, 50); // 相对移动 SkmCore.HKMMoveTo(HKMData, 200, 100); // 绝对移动 SkmCore.HKMLeftClick(HKMData); // 左键单击 SkmCore.HKMRightClick(HKMData); // 右键单击 SkmCore.HKMLeftDoubleClick(HKMData); // 左键双击 // 随机延时 SkmCore.HKMDelayRnd(HKMData, 100, 150); // 关闭设备 KMSimulatorService.CloseDevice(); 完整示例 参考 Program.cs 中的完整示例代码。 \uD83D\uDD27 配置说明 Config 类配置项 配置项 类型 默认值 说明 KMDeiviceVID int 0x2612 键鼠模拟器设备 VID KMDeivicePID int 0x1701 键鼠模拟器设备 PID KMVerifyUserData string - 键鼠模拟器校验数据 KMOffsetOfClick int 5 点击偏移量（像素） KMOutputStringType int 4 输出字符串编码类型 KMMouseMoveMode int 0 鼠标移动模式 ProcessDpiAwareness int 1 进程 DPI 感知值 DPI 感知配置 0: 不设置 DPI 感知 1: PROCESS_SYSTEM_DPI_AWARE - 根据主显示器 DPI（默认） 2: PROCESS_PER_MONITOR_DPI_AWARE - 根据每个显示器 DPI 注意: 键鼠模拟器受 DPI 感知影响，请正确设置 DPI。本 SDK 中也提供了 DpiAwareness 类供设置 DPI。 \uD83D\uDCDA API 文档 KMSimulatorService 类 设备管理服务类，提供设备初始化、搜索、打开、关闭等功能。 主要方法 Init(int deviceVID, int devicePID, string verifyUserData) - 初始化设备 SearchDevice(int deviceVID, int devicePID) - 搜索设备 OpenDevice(UInt32 deviceID) - 打开设备 CloseDevice() - 关闭设备 IsDeviceOpen() - 判断设备是否打开 SkmCore 类 skm.dll 的封装类，提供所有底层 API。 键盘操作 HKMKeyPress(IntPtr HKMData, string KeyName) - 按键 HKMKeyDown(IntPtr HKMData, string KeyName) - 按下 HKMKeyUp(IntPtr HKMData, string KeyName) - 弹起 HKMOutputString(IntPtr HKMData, string Str) - 输出字符串 HKMReleaseKeyboard(IntPtr HKMData) - 释放所有按键 鼠标操作 HKMMoveTo(IntPtr HKMData, int X, int Y) - 绝对移动 HKMMoveR(IntPtr HKMData, int X, int Y) - 相对移动 HKMLeftClick(IntPtr HKMData) - 左键单击 HKMRightClick(IntPtr HKMData) - 右键单击 HKMMiddleClick(IntPtr HKMData) - 中键单击 HKMLeftDoubleClick(IntPtr HKMData) - 左键双击 HKMMouseWheel(IntPtr HKMData, int Count) - 滚轮滚动 设备管理 HKMSearchDevice(UInt32 Vid, UInt32 Pid, UInt32 DeviceType) - 搜索设备 HKMOpen(UInt32 DeviceId, UInt32 DpiMode) - 打开设备 HKMClose(IntPtr HKMData) - 关闭设备 HKMSetMode(IntPtr HKMData, UInt32 Index, UInt32 Mode) - 设置模式 工具方法 HKMDelayRnd(IntPtr HKMData, UInt32 MinTime, UInt32 MaxTime) - 随机延时 HKMGetCursorPos(IntPtr HKMData, ref int X, ref int Y) - 获取鼠标坐标 更多 API 请参考 SKMCore.cs 文件。 ⚠️ 注意事项 DLL 文件: x64 环境需要使用 x64/skm.dll x86 环境需要使用 x86/skm.dll KMSimulatorService 会自动根据当前环境复制 DLL，无需手动处理 DPI 感知: DPI 感知设置必须在任何窗口创建之前调用 如果应用程序已经设置了 DPI 感知，库的设置将无效 设备连接: 使用前请确保键鼠模拟器设备已正确连接 检查设备 VID 和 PID 是否正确配置 字符串编码: 如果中文出现乱码，使用 HKMSetMode 改变输出字符串编码 默认使用剪贴板粘贴方式输出字符串，速度快且不受输入法影响 线程安全: 请确保设备操作在同一线程中进行，避免并发访问 \uD83D\uDD17 相关链接 SKSimulator 官方文档 使用SKSimulator的开发框架 - WeChatAuto.SDK 注意: 本项目仅用于学习和合法用途，请勿用于任何非法活动。"
  }
}